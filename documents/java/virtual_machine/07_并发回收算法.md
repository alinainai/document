## 并发回收


### 1 stop-the-world 现象

在标准的垃圾回收算法中，在垃圾回收线程（collector）进行 `标记 - 清理/整理/复制` 的过程中需要暂停所有的用户线程（mutator），这是为了保证能够彻底清理所有垃圾对象。

但是这种做法却会导致虚拟机的吞吐量降低 $（吞吐量 = \frac{运行用户代码时间} {垃圾回收频率 * 单次垃圾回收时间}）$


### 2 CMS 垃圾收集器

在追求响应速度的系统上，希望垃圾收集器暂停时间尽可能小，为此发展出了允许回收线程与用户线程并发运行的垃圾收集器 —— CMS（Concurrent Mark Sweep，并发标记清除）。
CMS 垃圾收集器的主要工作过程分为 4 个步骤：


- 1、初始标记（短暂 stop-the-world）：仅仅标记被 GC Root 直接引用的对象，由于 GC Root 相对较少，这个过程速度很块；
- 2、并发标记（耗时）：继续遍历 GC Root 引用链上的对象，这个过程比较耗时，所以采用并发处理；
- 3、重新标记（短暂 stop-the-world）：为了修正并发标记期间用户线程导致的引用关系变化，需要暂停用户线程重新标记；
- 4、并发清除（耗时） 由于清除对象的过程比较耗时，所以采用并发处理。

<img width="600" alt="CMS 垃圾收集器" src="https://user-images.githubusercontent.com/17560388/179744300-6868ea7a-bf07-4256-86bd-bbd67c3b7226.png">

—— 图片引用自网络

### 3 CMS 的优点

1、缩短了系统 stop-the-world 时间，提高了吞吐量；

### 4 CMS 的缺点

- 1、CPU 敏感：采用了并发策略，系统整体上会占用更多 CPU 资源；
- 2、浮动垃圾：由于并发清理的过程中用户线程还在运行，CMS 无法回收这个阶段中用户线程产生的垃圾，这一部分垃圾称为 “浮动垃圾”。由于浮动垃圾的存在，垃圾收集器需要预留出一部分空间来允许浮动垃圾的产生，如果预留的空间还不足以存放浮动垃圾，就会出现 Concurrent Mode Failure，此时需要临时启动非并发清理方案来代替 CMS；
- 3、内存碎片：采用标记 - 清理算法，会产生内存碎片。
