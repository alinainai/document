## 二、操作系统基础操作

>第二章的主要内容是 : 1、启动；2、中断/异常/系统调用

### 1、操作系统的启动过程

1. 当CPU接收到稳定电压后会先加载 `BIOS(Basic I/O System）`
2. BIOS运行后会先进行加电自检（Power－On Self Test）。
3. 自检完成后加载 Bootloader，将 Bootloader(512字节) 从磁盘的引导扇区加载到 0x7C00，将 CPU 的使用权出让给 Bootloader。
4. Bootloader 从磁盘中加载 OS 的代码和数据到内存中，跳转到操作系统的起始地址。

BIOS 是联系最底层的硬件系统和软件系统的桥梁，BIOS 存储在闪存的固定地址（`CS : IP = 0xF000 : 0xFFF0`）。Bootloader 和 OS 都存储在 Disk 中。


### 2、中断、异常、系统调用

操作系统如何实现中断、异常和系统调用

| 类型     | 源头                     | 处理时间   | 响应                 |
| -------- | ------------------------ | ---------- | -------------------- |
| 中断     | 外设                     | 异步       | 持续，对应用程序是透明 的|
| 异常     | 应用程序意想不到的行为   | 同步       | 杀死应用程序或重新执行应用程序的指令   |
| 系统调用 | 应用程序请求系统提供服务 | 同步或异步 | 等待和持续           |

#### 2.1 中断过程

外设的事件会引起终端系统中断（硬件设备、网络返回）。

硬件的工作：将内部、外部事件设置中断标记（中断事件的ID）

软件的工作
1.  保存当前处理状态（寄存器之类的一些数据）
2.  根据中断事件的ID跳转到中断服务程序，中断服务程序处理
3.  清楚中断标记

#### 2.2 异常

异常来源于不良的应用程序，非法指令或者其他坏的处理状态（如：内存出错）。

**异常处理流程**

1.  保存现场
2.  异常处理
    1.  杀死了产生异常的程序
    2.  重新执行异常指令
3.  恢复现场

#### 2.3 系统调用

应用程序主动向操作系统发出服务请求。应用程序通过访问高层次的API进行系统调用，不是直接调用系统调用函数。

系统调用会触 CPU 从用户态到内核态的转换，当然这种状态的切换需要一定的开销（有开销但是保证了安全）


### 其他

跨越操作系统边界（`应用程序 <--> OS <--> 硬件`）的开销：

-   在执行时间上的开销超过程序调用
-   开销：
    -   建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销
    -   建立内核堆栈
    -   验证参数
    -   内核态映射到用户态的地址空间（更新页面映射权限）
    -   内核态独立地址空间（TLB）

>   异步：应用程序不知道什么时候会发生中断

>   同步：执行到某一条指令一定会发生该事件


