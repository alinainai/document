## 一、概述

### 1.1 操作系统是什么？

用户角度：操作系统是一个控制软件

*  管理应用程序
*  为应用程序提供服务
*  杀死应用程序

程序角度：操作系统是资源管理器

*  管理外设、分配资源
*  抽象
    *  将CPU抽象成进程
    *  将磁盘抽象成文件
    *  将内存抽象成地址空间

### 1.2 操作系统层次

位于硬件之上，应用程序之下。

### 1.3 操作系统的界面和内核

Linux Windows Android 的界面属于外壳(Shell) ，而不是内核(kernel)。操作系统研究的是内核，处于Shell之下。

### 1.5 操作系统内部组件

*   CPU调度器
*   物理内存管理
*   虚拟内存管理
*   文件系统管理
*   中断处理与设备驱动

### 1.6 操作系统特征

*  并发
    *  一段时间内运行多个进程（并行 : 一个时间点运行多个进程，一般要求有多个CPU)
    *  需要OS管理和调度
*   共享
    *   “同时”共享
    *   互斥共享
*   虚拟
    *   让每一个用户觉得的有一个计算机专门为他服务
*   异步
    *   程序是走走停停，而不是一直运行

## 二、操作系统基础操作

>第二章的主要内容是 : 操作系统的异常/中断/系统调用

### 2.1 探究计算机启动过程

**作用解析**

Disk : 存放OS和Bootloader

BIOS : 基于I/O处理系统

Bootloader : 加载OS，将OS放入内存

**结构**

Disk

   |___ OS

   |___ Bootloader

**开机流程**

1.  BIOS
    *   开机后，寻找显卡和执行BIOS (此时, `CS : IP = 0xF000 : 0xFFF0`,  CS/IP 两个寄存器) 
    *   将Bootloader从磁盘的引导扇区加载到0x7C00 (Bootloader一共占用512M字节的内存)
    *   跳转到 `CS : IP = 0x0000 : 0x7C00`

2.  Bootloader
    *   将操作系统的代码和数据从硬盘加载到内存中
    *   跳转到操作系统的起始地址

### 2.2 中断、异常、系统调用

#### 中断

中断来源于外设，来自不同的硬件设备的计时器和网络的中断。

**中断流程**

硬件：设置中断标记（CPU初始化）

1.  将内部、外部事件设置中断标记
2.  中断事件的ID

软件

1.  保存当前处理状态（寄存器之类的一些数据）
2.  根据中断事件的ID跳转到中断服务程序，中断服务程序处理
3.  清楚中断标记

#### 异常

异常来源于不良的应用程序，非法指令或者其他坏的处理状态（如：内存出错）。

**异常处理流程**

1.  保存现场
2.  异常处理
    1.  杀死了产生异常的程序
    2.  重新执行异常指令
3.  恢复现场

#### 系统调用

系统调用来源于应用程序，应用程序主动向操作系统发出服务请求。程序访问主要是通过高层次的API，而不是直接调用系统调用函数。

**APIs**

-   Win32 API 用于Windows
-   POSIX API 用于 POSIX-based systems（包括UNIX，LINUX，Mac OS X）
-   Java API 用于JAVA虚拟机

**特点**

-   通常情况下，每个系统调用有对应的序号
    -   系统调用接口根据这些序号来维护表的索引
-   系统调用接口调用内核态中预期的系统调用
    -   并返回系统调用的状态和其他任何返回值
-   用户不需要知道系统调用是如何实现的
    -   只需要获取API和了解操作系统将什么作为返回结果
    -   操作系统接口的细节大部分都隐藏在API中

**用户态**：操作系统运行中，CPU处于的特权级别，不能直接执行特权指令

**内核态**：操作系统运行中，CPU处于的特权级别，可以执行任何一条指令

**系统调用**：触发CPU从用户态到内核态的转换，切换程序和内核的堆栈，需要一定的开销

**跨越操作系统边界的开销（值得的且必须的，保证了操作系统的安全性）**

-   在执行时间上的开销超过程序调用
-   开销：
    -   建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销
    -   建立内核堆栈
    -   验证参数
    -   内核态映射到用户态的地址空间（更新页面映射权限）
    -   内核态独立地址空间（TLB）

#### 区别

| 类型     | 源头                     | 处理时间   | 响应                 |
| -------- | ------------------------ | ---------- | -------------------- |
| 中断     | 外设                     | 异步       | 持续，对应用程序透明 |
| 异常     | 应用程序意向不到的行为   | 同步       | 杀死或重新执行指令   |
| 系统调用 | 应用程序请求系统提供服务 | 同步或异步 | 等待和持续           |

>   异步：应用程序不知道什么时候会发生中断

>   同步：执行到某一条指令一定会发生该事件

### 为什么应用程序不能直接访问硬件？

-   在计算机运行时，内核是被信任的第三方
-   只有内核可以执行特权指令
-   为了方便应用程序

>   第三章的主要内容是：操作系统的物理内存管理

## 计算机体系结构

1.  CPU
2.  内存
3.  I/O

## 内存分层体系

### 内存分层体系

运行内存(主存) / 磁盘(虚拟内存). 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间.

CPU可以访问的内存包括两大类 : 寄存器 / cache(L1缓存 / L2缓存)

**层次**

微处理器(CPU访问)

|___CPU寄存器 / L1缓存

|___L2缓存

主存(程序访问)

磁盘(程序访问)

>   从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。

### 内存管理目标

*   抽象：逻辑地址空间

*   保护：独立地址空间

*   共享：访问相同内存

*   虚拟：更多的地址空间

### 内存管理方法

*   程序重定位
*   分段
*   分页
*   虚拟内存
*   按需分页虚拟内存

>   实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求

## 地址空间

地址空间的定义

*   物理地址空间 —— 硬件支持的地址空间( address : [0, Max_sys] )
*   逻辑地址空间 —— 一个运行在程序所拥有的的内存范围( address : [0, Max_prog] )

## 连续内存分配

### 内存碎片问题

内存碎片问题指的是空闲的内存无法被利用

*   外部碎片 : 分配单元间的未使用内存
*   内部碎片 : 分配单元内的未使用内存

### 分区的动态分配

分区的动态分配方式有以下三种 :

1.  第一匹配分配 : 在内存中找到第一个比需求大的空闲块, 分配给应用程序
2.  最优适配分配 : 在内存中找到最小的空闲块, 分配给应用程序
3.  最差适配分配 : 在内存中找到最大的空闲块, 分配给应用程序

分配方式的区别

| 分配方式 | 第一匹配分配 | 最优适配分配 | 最差适配分配 |
| ---------------- | ----------------- | ------------------- | ------------------ |
| 分配方式实现需求 | 1. 按地址排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 | 1. 按尺寸排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 | 1. 按尺寸排序的空闲块列表<br />2. 分配最大的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 |
| 优势             | 简单 / 易于产生更大空闲块                                    | 比较简单 / 大部分分配是小尺寸时高效                          | 分配很快 / 大部分分配是中尺寸时高效                          |
| 劣势             | 产生外部碎片 / 不确定性                                      | 产生外部碎片 / 重分配慢 / 产生很多没用的微小碎片             | 产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配 |

>   三种分配方式并无优劣之分，因为我们无法判断内存请求的大小

## 碎片整理方法

可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。

1.  压缩式碎片整理
    *   重置程序以合并碎片
    *   要求所有程序是动态可重置的
    *   问题 : 
        *   何时重置 ? (在程序处于等待状态时才可以重置)
        *   需要考虑内存拷贝的开销

2.  交换式碎片整理

    *   运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存

    *   问题 :

        *   哪些程序应该被回收 ?

    *   情况 :

        运行中 : P3

        等待中 : P1 P2 P4

        内存分布 -> 主存 : OS / P1 / P3 / P2 / P4 磁盘 : 空

        当P3程序需要更大的内存时 ->

        内存分布 -> 主存 : OS / P1 / P3 / P2         磁盘 : P4



#### 为什么要内存对齐

- 1.平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。
- 2.硬件原因：经过内存对齐后，CPU访问内存的速度大大提升。

大家可能会发现内存对齐岂不是浪费的内存资源么？

是这样的，但事实上，相对来说计算机内存资源一般都是充足的，我们更希望的是提高运行速度。

编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响。
