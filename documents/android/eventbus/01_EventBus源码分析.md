## 1、使用方式

github 地址:[https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)

<img width="400" alt="类图" src="https://user-images.githubusercontent.com/17560388/163953816-f7cfffd7-e2a2-4fc9-aa11-d88fe7102600.png">

添加依赖

```groovy
implementation("org.greenrobot:eventbus:3.3.1")
```
### 1.1 简单使用

1.定义事件 和 事件接收的方法

```java
public static class MessageEvent { /* Additional fields if needed */ }

@Subscribe(threadMode = ThreadMode.MAIN)  
public void onMessageEvent(MessageEvent event) {
    // Do something
}
```

2.在 Activity 或者 Fragment 中注册和反注册

```java
@Override
public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
}
@Override
public void onStop() {
    super.onStop();
    EventBus.getDefault().unregister(this);
}
```

3.发送事件
```java
EventBus.getDefault().post(new MessageEvent());
```

### 1.2 进阶使用

EventBus3.0 之后,可以通过 Subscriber Index 使用 APT 技术来完成方法注册

[Subscriber Index](https://greenrobot.org/eventbus/documentation/subscriber-index/)

使用方式

```groovy
apply plugin: 'kotlin-kapt' // ensure kapt plugin is applied
 
dependencies {
    def eventbus_version = '3.2.0'
    implementation "org.greenrobot:eventbus:$eventbus_version"
    kapt "org.greenrobot:eventbus-annotation-processor:$eventbus_version"
}
 
kapt {
    arguments {
        arg('eventBusIndex', 'com.eventbus.project.MyEventBusIndex') //包名可以根据自身项目更改
    }
}
```
重新 build 项目，在对应的 build 目录下会生成 MyEventBusIndex 对象。

```java
/** This class is generated by EventBus, do not edit. */
public class MyEventBusIndex implements SubscriberInfoIndex {
    // 缓存 Class 和 SubscriberInfo 的容器
    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;

    static {
        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();
        // 将 class 和 SubscriberMethods 的对应关系包装为 SubscriberInfo 并添加到缓存容器中
        putIndex(new SimpleSubscriberInfo(com.mihua.ljxbao.ui.splash.Test1Activity.class, true,
                new SubscriberMethodInfo[] {
            new SubscriberMethodInfo("onMessageEvent", com.mihua.ljxbao.ui.splash.MessageEvent.class, ThreadMode.MAIN),
        }));

    }

    private static void putIndex(SubscriberInfo info) {
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }

    //通过注册类获取类对应的 SubscriberInfo
    @Override
    public SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}
```
### 在 Eventbus 中注册 index 的两种方式

Then, e.g. in your Application class, use EventBus.builder().addIndex(indexInstance) to pass an instance of the index class to EventBus.
```java
EventBus eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build();
```

Use EventBusBuilder.installDefaultEventBus() to set the EventBus with index as the instance returned by EventBus.getDefault().
```java
EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();
// Now the default instance uses the given index. Use it like this:
EventBus eventBus = EventBus.getDefault();
```
我觉得第二种比较不错，赋值之后直接使用 getDefault()

## 2、源码分析

咱们按照使用顺序去追踪一下源码

### 2.1 register(object) 方法

```java
public void register(Object subscriber) {
    ...
    //获取 subscriber 对象的 Class 
    Class<?> subscriberClass = subscriber.getClass();
    // 查找 subscriberClass 中所有可以接收 event 消息的方法存入 List，后面具体分析
    List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
    synchronized (this) {
        for (SubscriberMethod subscriberMethod : subscriberMethods) {
            subscribe(subscriber, subscriberMethod);
        }
    }   
}
```

先简单看一下 SubscriberMethod 类和它的参数，这个类是对 register(class) 类中的 @Subscribe 方法的包装

```java
public class SubscriberMethod {
    final Method method;
    final ThreadMode threadMode; //方法执行的线程标志
    final Class<?> eventType; //事件的类型
    final int priority; //优先级
    final boolean sticky; //是否是粘性事件，粘性事件
```

我们继续追踪 `SubscriberMethodFinder#findSubscriberMethods(subscriberClass)` 方法，来看下 List<SubscriberMethod> 是怎么查找的

```java 
List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
    if (subscriberMethods != null) { // 有缓存直接返回
        return subscriberMethods;
    }
    // ignoreGeneratedIndex 表示是否忽略注解器生成的 MyEventBusIndex，默认为 false，可以通过 EventBusBuilder 来设置它的值
    if (ignoreGeneratedIndex) { //不使用 MyEventBusIndex，通过反射的形式获取 subscriberMethods
        subscriberMethods = findUsingReflection(subscriberClass);
    } else {
        subscriberMethods = findUsingInfo(subscriberClass);
    }
    if (subscriberMethods.isEmpty()) { //如果注册的类中没有 SubscriberMethod 方法，直接抛出有异常
        throw new EventBusException("Subscriber " + subscriberClass + " and its super classes have no public methods with the @Subscribe annotation");
    } else { 
        //保存并返回 List<SubscriberMethod> 对象
        METHOD_CACHE.put(subscriberClass, subscriberMethods);
        return subscriberMethods;
    }
}
```

再来看下`SubscriberMethodFinder#findSubscriberMethods(subscriberClass)` 方法，该方法比较简单。

```java
private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
    FindState findState = prepareFindState(); //
    findState.initForSubscriber(subscriberClass);
    while (findState.clazz != null) {
        findUsingReflectionInSingleClass(findState); //核心方法，下面分析
        findState.moveToSuperclass(); //继续搜寻父类中的 @Subscriber 方法
    }
    return getMethodsAndRelease(findState); // 释放 FindState 对象到对象池
}
```
    
`SubscriberMethodFinder#prepareFindState()` 里面有个不错的知识点，采用对象池的方式缓存 FindState 对象。
    
```java
//对象池
private static final int POOL_SIZE = 4;
private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
//从对象池中获取 FindState 对象，没有的话就新建一个 FindState
private FindState prepareFindState() {
    synchronized (FIND_STATE_POOL) {
        for (int i = 0; i < POOL_SIZE; i++) {
            FindState state = FIND_STATE_POOL[i];
            if (state != null) {
                FIND_STATE_POOL[i] = null;
                return state;
            }
        }
    }
    return new FindState();
}
//使用完成之后将 FindState recycle , 并存储到 对象池中
private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
    List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
    findState.recycle();
    synchronized (FIND_STATE_POOL) {
        for (int i = 0; i < POOL_SIZE; i++) {
            if (FIND_STATE_POOL[i] == null) {
                FIND_STATE_POOL[i] = findState;
                break;
            }
        }
    }
    return subscriberMethods;
}
```
再来看下 `SubscriberMethodFinder#findUsingInfo(subscriberClass)` 方法。
```java                                                                    
private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
    FindState findState = prepareFindState();
    findState.initForSubscriber(subscriberClass);
    while (findState.clazz != null) {
        findState.subscriberInfo = getSubscriberInfo(findState);
        if (findState.subscriberInfo != null) {
            // subscriberInfo 不为空，直接从 subscriberInfo 获取 SubscriberMethods
            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
            for (SubscriberMethod subscriberMethod : array) {
                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
                    findState.subscriberMethods.add(subscriberMethod);
                }
            }
        } else {
            findUsingReflectionInSingleClass(findState);
        }
        findState.moveToSuperclass();
    }
    return getMethodsAndRelease(findState);
}                                                                       
```  
这个方法主要是处理咱们上面讲过的 3.0+ 版本使用 Index 对 EventBus 的优化。先查询能不能获取到 subscriberClass 对用的 SubscriberInfo 对象，然后从 SubscriberInfo 中获取 SubscriberMethod 的集合。

                                                                      
再看下 `SubscriberMethodFinder#findUsingReflectionInSingleClass(findState)` 方法

```java
private void findUsingReflectionInSingleClass(FindState findState) {
    Method[] methods;
    try {
        // This is faster than getMethods, especially when subscribers are fat classes like Activities
        methods = findState.clazz.getDeclaredMethods();
    } catch (Throwable th) {
        // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
        try {
            methods = findState.clazz.getMethods();
        } catch (LinkageError error) { // super class of NoClassDefFoundError to be a bit more broad...
            String msg = "Could not inspect methods of " + findState.clazz.getName();
            if (ignoreGeneratedIndex) {
                msg += ". Please consider using EventBus annotation processor to avoid reflection.";
            } else {
                msg += ". Please make this class visible to EventBus annotation processor to avoid reflection.";
            }
            throw new EventBusException(msg, error);
        }
        findState.skipSuperClasses = true;
    }
    // 上面是获取 subscriberClass 中的所有方法
    for (Method method : methods) {
        int modifiers = method.getModifiers();
        if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
            Class<?>[] parameterTypes = method.getParameterTypes();
            if (parameterTypes.length == 1) {
                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                //将有 @Subscribe 注解的方法和注解中参数生成一个 SubscriberMethod 对象，并添加到集合中
                if (subscribeAnnotation != null) {
                    Class<?> eventType = parameterTypes[0];
                    if (findState.checkAdd(method, eventType)) {
                        ThreadMode threadMode = subscribeAnnotation.threadMode();
                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                    }
                }
            } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
                String methodName = method.getDeclaringClass().getName() + "." + method.getName();
                throw new EventBusException("@Subscribe method " + methodName +
                        "must have exactly 1 parameter but has " + parameterTypes.length);
            }
        } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
            String methodName = method.getDeclaringClass().getName() + "." + method.getName();
            throw new EventBusException(methodName +
                    " is a illegal @Subscribe method: must be public, non-static, and non-abstract");
        }
    }
 }
```
findUsingReflectionInSingleClass 方法通过反射的方式查找 subscriberClass 中的 SubscriberMethod 方法并添加到集合中

查找 List<SubscriberMethod> 的过程到这里就结束了，下面我们看下 `EventBus#register(subsricberClass)` 中调用的 `subscribe` 方法

```java
// 存储 eventType 和 subscriptions 对象
private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
//存储 订阅者 和 订阅方法使用到的 eventType
private final Map<Object, List<Class<?>>> typesBySubscriber;

// Must be called in synchronized block
private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
    // 获取 subscriberMethod 方法中使用的事件类型
    Class<?> eventType = subscriberMethod.eventType; 
    // 新建一个订阅对象
    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
    // 根据事件类型获取订阅对象的集合
    CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
    if (subscriptions == null) {
        subscriptions = new CopyOnWriteArrayList<>();
        subscriptionsByEventType.put(eventType, subscriptions); //将订阅对象集合添加到 subscriptionsByEventType 中
    } else {
        if (subscriptions.contains(newSubscription)) {
            throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
                    + eventType);
        }
    }

    int size = subscriptions.size();
    for (int i = 0; i <= size; i++) { //处理优先级
        if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
            subscriptions.add(i, newSubscription);
            break;
        }
    }
    //通过 subscriber 查找对应的 eventTypes 列表
    List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
    if (subscribedEvents == null) {
        subscribedEvents = new ArrayList<>();
        typesBySubscriber.put(subscriber, subscribedEvents);
    }
    //将 eventType 添加到 subscribedEvents
    subscribedEvents.add(eventType);

    if (subscriberMethod.sticky) {//处理粘性事件
        if (eventInheritance) {
            // Existing sticky events of all subclasses of eventType have to be considered.
            // Note: Iterating over all events may be inefficient with lots of sticky events,
            // thus data structure should be changed to allow a more efficient lookup
            // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
            Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
            for (Map.Entry<Class<?>, Object> entry : entries) {
                Class<?> candidateEventType = entry.getKey();
                if (eventType.isAssignableFrom(candidateEventType)) {
                    Object stickyEvent = entry.getValue();
                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                }
            }
        } else {
            Object stickyEvent = stickyEvents.get(eventType);
            checkPostStickyEventToSubscription(newSubscription, stickyEvent);
        }
    }
}
```
这个方法将 订阅者、订阅者中的订阅方法 和 evnetType 缓存到 EventBus 中对应的容器里。

#### 3.2 发送事件 EventBus.getDefault().post(MessageEvent())
```java
public void post(Object event) {
    // currentPostingThreadState 是一个 ThreadLocal
    PostingThreadState postingState = currentPostingThreadState.get();
    List<Object> eventQueue = postingState.eventQueue;
    eventQueue.add(event);// 将消息添加到 eventQueue

    if (!postingState.isPosting) { // 如果没有在发送事件
        postingState.isMainThread = isMainThread();
        postingState.isPosting = true; // 改变发送状态
        if (postingState.canceled) {
            throw new EventBusException("Internal error. Abort state was not reset");
        }
        try {
            while (!eventQueue.isEmpty()) {
                // 发送事件
                postSingleEvent(eventQueue.remove(0), postingState);
            }
        } finally {
            postingState.isPosting = false;
            postingState.isMainThread = false;
        }
    }
}
```
首先根据 currentPostingThreadState 获取当前线程状态 postingState 。currentPostingThreadState 其实就是一个 ThreadLocal 类的对象，不同的线程根据自己独有的索引值可以得到相应属于自己的 postingState 数据。然后把事件 event 加入到 eventQueue 队列中排队。循环遍历 eventQueue ，取出事件发送事件。发送单个事件是调用 postSingleEvent(Object event, PostingThreadState postingState) 方法。

再来看下 `EventBus#postSingleEvent(event,postingState)` 方法

```java
private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
    Class<?> eventClass = event.getClass(); // 获取事件的Class
    boolean subscriptionFound = false; // 是否找到订阅者
    if (eventInheritance) {// 如果支持事件继承，默认为支持
        List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);// 查找 eventClass 的所有父类和接口
        int countTypes = eventTypes.size();
        for (int h = 0; h < countTypes; h++) {
            // 依次向 eventClass 的父类或接口的订阅方法发送事件
            // 只要有一个事件发送成功，返回 true ，那么 subscriptionFound 就为 true，|= 按位或操作
            Class<?> clazz = eventTypes.get(h);
            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
        }
    } else {
        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
    }
    if (!subscriptionFound) { // 没有发现订阅者
        if (logNoSubscriberMessages) {
            logger.log(Level.FINE, "No subscribers registered for event " + eventClass);
        }
        if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
                eventClass != SubscriberExceptionEvent.class) {
            post(new NoSubscriberEvent(this, event));
        }
    }
}
    
private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
    CopyOnWriteArrayList<Subscription> subscriptions;
    synchronized (this) {
        // 根据事件类型获取 Subscription 列表
        subscriptions = subscriptionsByEventType.get(eventClass);
    }
    if (subscriptions != null && !subscriptions.isEmpty()) {
        for (Subscription subscription : subscriptions) {
            postingState.event = event;
            postingState.subscription = subscription;
            boolean aborted;
            try {
                // 发送事件
                postToSubscription(subscription, event, postingState.isMainThread);
                // 是否被取消
                aborted = postingState.canceled;
            } finally {
                postingState.event = null;
                postingState.subscription = null;
                postingState.canceled = false;
            }
            if (aborted) {// 如果被取消，则跳出循环
                break;
            }
        }
        return true;
    }
    return false;
}

private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
    switch (subscription.subscriberMethod.threadMode) { // 根据不同的线程模式执行对应的分支
        case POSTING:
            invokeSubscriber(subscription, event);
            break;
        case MAIN:
            if (isMainThread) {
                invokeSubscriber(subscription, event);
            } else {
                mainThreadPoster.enqueue(subscription, event);
            }
            break;
        case MAIN_ORDERED:
            if (mainThreadPoster != null) {
                mainThreadPoster.enqueue(subscription, event);
            } else {
                // temporary: technically not correct as poster not decoupled from subscriber
                invokeSubscriber(subscription, event);
            }
            break;
        case BACKGROUND:
            if (isMainThread) {
                backgroundPoster.enqueue(subscription, event);
            } else {
                invokeSubscriber(subscription, event);
            }
            break;
        case ASYNC:
            asyncPoster.enqueue(subscription, event);
            break;
        default:
            throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);
    }
}
```
#### 3.3 EventBus.unregister() 解绑操作

在订阅类销毁的时候要对 EventBus 进行解绑操作。

```java
/** Unregisters the given subscriber from all event classes. */
public synchronized void unregister(Object subscriber) {
    // 获取订阅对象的所有订阅事件类集合
    List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
    if (subscribedTypes != null) {
        for (Class<?> eventType : subscribedTypes) {
            // 移除订阅者的订阅信息
            unsubscribeByEventType(subscriber, eventType);
        }
        // 移除订阅者
        typesBySubscriber.remove(subscriber);
    } else {
        logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass());
    }
}


/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
    // 获取事件类的所有订阅信息列表，将订阅信息从订阅信息集合中移除，同时将订阅信息中的active属性置为FALSE
    List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
    if (subscriptions != null) {
        int size = subscriptions.size();
        for (int i = 0; i < size; i++) {
            Subscription subscription = subscriptions.get(i);
            if (subscription.subscriber == subscriber) {
                subscription.active = false;
                subscriptions.remove(i);
                i--;
                size--;
            }
        }
    }
}
```

## 参考

- [EventBus索引分析](https://www.jianshu.com/p/25388d6446bf)

[第三方开源库 EventBus - 源码分析和手写](https://www.jianshu.com/p/0b35f448acec)
                                 
[Subscriber Index](https://greenrobot.org/eventbus/documentation/subscriber-index/)
