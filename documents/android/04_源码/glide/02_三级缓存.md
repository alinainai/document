## 一、三级缓存

我们先看下三级缓存是哪三级

1、WeakReference（弱引用），使用弱引用来缓存图片，图片被回收后，会先保存到内存缓存中。  

2、LruCache（内存缓存），弱引用中缓存找不到图片，就从内存缓存中查找。找到图片后，删除内存缓存（防止因 lru 的策略，图片正在使用，但是被回收掉的问题）

3、DiskLrucache（磁盘缓存），上面两级缓存都没有找到图片，就去在磁盘缓存中找到，就把图片加载后，放到弱引用缓存中。磁盘缓存数据的种类有两种，一种是缓存源数据，这种数据需要经过解析才能得到图片。一种是图片数据，直接加载进来就可以用的。可以通过diskCacheStrategyOf 来自由选择如何缓存

三级缓存的逻辑封装在 Engine#load 方法中，我们先看下该方法

### 1、Engine#load 方法

```java    
public synchronized <R> LoadStatus load(
        GlideContext glideContext,
        Object model,
        Key signature,
        int width,
        int height,
        Class<?> resourceClass,
        Class<R> transcodeClass,
        Priority priority,
        DiskCacheStrategy diskCacheStrategy,
        Map<Class<?>, Transformation<?>> transformations,
        boolean isTransformationRequired,
        boolean isScaleOnlyOrNoTransform,
        Options options,
        boolean isMemoryCacheable,
        boolean useUnlimitedSourceExecutorPool,
        boolean useAnimationPool,
        boolean onlyRetrieveFromCache,
        ResourceCallback cb,
        Executor callbackExecutor) {
    long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;

    // 1、生成标识符key，根据这个key，在缓存中查找图片
    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
            resourceClass, transcodeClass, options);

    // 2、检查弱引用缓存是否有目标图片
    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
    if (active != null) {
        // 在弱引用缓存中找到图片，直接返回
        cb.onResourceReady(active, DataSource.MEMORY_CACHE);
        if (VERBOSE_IS_LOGGABLE) {
            logWithTimeAndKey("Loaded resource from active resources", startTime, key);
        }
        return null;
    }
    // 3、检查内存的缓存，是否有目标图片
    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
    if (cached != null) {
        // 在内存缓存中找到图片，直接返回
        cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
        if (VERBOSE_IS_LOGGABLE) {
            logWithTimeAndKey("Loaded resource from cache", startTime, key);
        }
        return null;
    }
		// 4、在弱引用和内存缓存中，都没有找到图片，就执行任务。这个任务，会现在磁盘缓存中查找，因为磁盘读取耗时较大，所以放在任务线程中
    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
    if (current != null) {
        current.addCallback(cb, callbackExecutor);
        if (VERBOSE_IS_LOGGABLE) {
            logWithTimeAndKey("Added to existing load", startTime, key);
        }
        return new LoadStatus(cb, current);
    }
		// 创建一个执行工作，它里面有很多Executor，其它线程可以放进来执行 
    EngineJob<R> engineJob = engineJobFactory.build(
                    key,
                    isMemoryCacheable,
                    useUnlimitedSourceExecutorPool,
                    useAnimationPool,
                    onlyRetrieveFromCache);
		// 创建一个解码工作，用于解码图片
    DecodeJob<R> decodeJob = decodeJobFactory.build(
                    glideContext,
                    model,
                    key,
                    signature,
                    width,
                    height,
                    resourceClass,
                    transcodeClass,
                    priority,
                    diskCacheStrategy,
                    transformations,
                    isTransformationRequired,
                    isScaleOnlyOrNoTransform,
                    onlyRetrieveFromCache,
                    options,
                    engineJob);
    // 放在Jobs内部维护的HashMap中
    jobs.put(key, engineJob);
    // 注册ResourceCallback接口，就是在成功获取图片后，需要显示到ImageView 上的回调，这个接口回调到SingleRequest 中
    engineJob.addCallback(cb, callbackExecutor);
    //开始执行
    engineJob.start(decodeJob);
        
    return new LoadStatus(cb, engineJob);
}
```

public synchronized void start(DecodeJob<R> decodeJob) {
        this.decodeJob = decodeJob;
        //若能从磁盘缓存获取数据，就使用diskCacheExecutor
        //否则在根据其他的条件判断使用哪个Executor
        GlideExecutor executor = decodeJob.willDecodeFromCache()
                ? diskCacheExecutor
                : getActiveSourceExecutor();
        executor.execute(decodeJob);
    }


    boolean willDecodeFromCache() {
        //先看下面的getNextStage 分析
        Stage firstStage = getNextStage(Stage.INITIALIZE);
        //那这里就很明了了，如果可以从磁盘缓存读取，就返回true
        return firstStage == Stage.RESOURCE_CACHE || firstStage == Stage.DATA_CACHE;
    }
1
2
3
4
5
6
很多地方都用到这个函数，获取下一个阶段，应该从哪里获取数据

    private Stage getNextStage(Stage current) {
        switch (current) {
            case INITIALIZE:
            //当前是初始阶段，则看磁盘缓存策略，是否可以在磁盘中获取资源缓存（也就是解析后的缓存）
                return diskCacheStrategy.decodeCachedResource()
                        ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);
            case RESOURCE_CACHE:
            //当前是资源缓存，看下一步能不能从磁盘缓存中获取源数据缓存
                return diskCacheStrategy.decodeCachedData()
                        ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
            case DATA_CACHE:
                // Skip loading from source if the user opted to only retrieve the resource from cache.
                //当前是数据缓存，下一步能不能从源数据处获取数据，例如从服务器获取
                return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
            case SOURCE:
            case FINISHED:
                return Stage.FINISHED;
            default:
                throw new IllegalArgumentException("Unrecognized stage: " + current);
        }
    }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
executor.execute(decodeJob); 会进入到 Decodejob 的run 函数，接着调用runWrapped，下面就进入该函数看看

10、Decodejob # runWrapped
    /**
     * 初始化之后第一次运行时 runReason 为 INITIALIZE
     */
    private void runWrapped() {
        runWrappedCount++;
        switch (runReason) {
            case INITIALIZE:
                //获取下一阶段的状态
                stage = getNextStage(Stage.INITIALIZE);
                //根据下一阶段状态，判断具体有哪个类执行
                currentGenerator = getNextGenerator();
                runGenerators();
                break;
            case SWITCH_TO_SOURCE_SERVICE:
                runGenerators();
                break;
            case DECODE_DATA:
                decodeFromRetrievedData();
                break;
            default:
                throw new IllegalStateException("Unrecognized run reason: " + runReason);
        }
    }

    private DataFetcherGenerator getNextGenerator() {
        switch (stage) {
            //从磁盘缓存获取资源数据
            case RESOURCE_CACHE:
                return new ResourceCacheGenerator(decodeHelper, this);
            //从磁盘缓存获取源数据
            case DATA_CACHE:
                return new DataCacheGenerator(decodeHelper, this);
            //从数据源获取数据，例如 从服务器获取数据
            case SOURCE:
                return new SourceGenerator(decodeHelper, this);
            case FINISHED:
                return null;
            default:
                throw new IllegalStateException("Unrecognized stage: " + stage);
        }
    }

    private void runGenerators() {
        currentThread = Thread.currentThread();
        startFetchTime = LogTime.getLogTime();
        boolean isStarted = false;
        while (!isCancelled && currentGenerator != null
                   //这里执行当前的Generator，进第11步
                && !(isStarted = currentGenerator.startNext())) {

            stage = getNextStage(stage);
            currentGenerator = getNextGenerator();

            if (stage == Stage.SOURCE) {
                reschedule();
                return;
            }
        }
        // We've run out of stages and generators, give up.
        if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {
            notifyFailed();
        }

        // Otherwise a generator started a new load and we expect to be called back in
        // onDataFetcherReady.
    }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
currentGenerator.startNext() 这里的currentGenerator 是SourceGenerator
————————————————
版权声明：本文为CSDN博主「薛瑄」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xx326664162/article/details/107663872
   
