## 1、属性动画是啥

属性动画通过更改控件的属性来实现动画，属性要有 `getter` 和 `setter` 方法。

- 位移:`translationX`、`translationY`、`translationZ`
- 透明度:`alpha`,透明度全透明到不透明:`0f->1f`
- 旋转:`rotation`,旋转一圈:`0f->360f`
- 缩放：水平缩放`scaleX`,垂直缩放`scaleY`

## 2、基本使用

相关参数：
- `duration=3000` 控制动画执行一次的时间
- `repeatCount=2` 控制动画重复执行的次数，`ValueAnimator.INFINITE` 表示无限循环
- `repeatMode=ValueAnimator.REVERSE` 设置动画重复执行的效果，`ValueAnimator.RESTART`和`ValueAnimator.REVERSE`


### 2.1 位移
```kotlin
ObjectAnimator.ofFloat(View(this), View.TRANSLATION_X, 0f, -70f)
ObjectAnimator.ofFloat(View(this), View.TRANSLATION_Y, 0f, -70f)
ObjectAnimator.ofFloat(View(this), View.TRANSLATION_Z, 0f, -70f)
```
通过 ObjectAnimator 的工厂方法 ofFloat 我们得到一个 ObjectAnimator 对象，并通过该对象的 start() 方法，开启动画效果。

- 第一个参数为要实现动画效果的View，例如这里整体效果的LinearLayout；
- 第二个参数为属性名，也就是前面所说的：translationX,translationY,alpha,rotation,scaleX,scaleY等，这里要实现的是水平平移效果，所以我们采用了translationX;
- 第三参数为可变长参数，第一个值为动画开始的位置，第二个值为结束值得位置，如果数组大于3位数，那么前者将是后者的起始位置。

Tips: 
- 如果可变长参数只有一个值，那么 ObjectAnimator 的工厂方法会将值作为动画结束值，此时属性必须拥有 初始化值 和 getXXX 方法。
- translationX 和 translationY这里涉及到的位移都是相对自身位置而言。例如 View 在点 A(x,y)要移动到点 B(x1,y1),那么ofFloat() 方法的可变长参数，第一个值应该0f,第二个值应该x1-x。

### 2.2 透明度
```kotlin
ObjectAnimator.ofFloat(tvText, "alpha", 1f,0f,1f)
```
### 2.3 缩放
```kotlin
ObjectAnimator.ofFloat(text, View.SCALE_X, 1f,2f)
ObjectAnimator.ofFloat(text, View.SCALE_Y, 1f,2f)
```
### 2.4 旋转
```kotlin
// View.ROTATION、View.ROTATION_X、View.ROTATION_Y
ObjectAnimator.ofFloat(tvText, View.ROTATION, 0f,180f,0f)
```
Tips: 对于可变长参数，如果后者的值大于前者，那么顺时针旋转，小于前者，则逆时针旋转。

## 3、动画组合

可以通过 AnimatorSet 设置多个动画的组合
```kotlin
AnimatorSet().apply {
    play(anim1).before(anim2)//1 在 2 之前播放
    play(anim2).with(anim3)//2 和 3 同时播放动画效果
    play(anim4).after(anim3)//4 在 3 播放结束之后播放
    start()
}

AnimatorSet().apply {
    playSequentially(aAnimator,bAnimator,cAnimator,dAnimator) //顺序播放
    start()
}

AnimatorSet().apply {
    playTogether(animator,bAnimator,cAnimator,dAnimator) //同时播放
    start()
}

AnimatorSet ().apply {
    play(aAnimator).after(1000) //1秒后播放a动画
    start()
}
```
## 4、ViewPropertyAnimator
如果只是针对View对象的特定属性同时播放动画，我们也可以采用ViewPropertyAnimator。
例如：
 tvText.animate().translationX(100f).translationY(100f).start()
复制代码支持属性：

translationX、translationY、translationZ
x、y、z
alpha
scaleX、scaleY

注意到ViewPropertyAnimator对象具有property(Float)和propertyBy(Float)方法，其中property(Float)是指属性变化多少(可以理解一次有效)，而propertyBy(Float)每次变化多少（可以理解多次有效）。
举例说明：
translationX
tvText.setOnClickListener {
    val animator = tvText.animate()
    animator.duration=1000
    animator.translationX(100f)//点击一次会向右偏移，再点击没效果
    animator.start()
}
复制代码
translationXBy
tvText.setOnClickListener {
    val animator = tvText.animate()
    animator.duration=1000
    animator.translationXBy(100f)//每次点击都会向右偏移
    animator.start()
}
复制代码
五、ValueAnimator与ObjectAnimator
ValueAnimator作为ObjectAnimator的父类，主要动态计算目标对象属性的值，然后设置给对象属性，达到动画效果，而ObjectAnimator则在ValueAnimator的基础上极大地简化对目标对象的属性值的计算和添加效果，融合了 ValueAnimator 的计时引擎和值计算以及为目标对象的命名属性添加动画效果这一功能。
举个栗子，通过ValueAnimator的工厂方法ofFloat、ofInt、ofArgb、ofObject来实现动画效果：

代码如下：
    //ValueAnimator实现
    tvText.setOnClickListener {
        val valueAnimator = ValueAnimator.ofFloat(0f, 180f)
        valueAnimator.addUpdateListener {
               tvText.rotationY = it.animatedValue as Float //手动赋值
        }
        valueAnimator.start()
    }
    //ObjectAnimator实现
     ObjectAnimator.ofFloat(tvText, "rotationY", 0f, 180f).apply { start() }
复制代码从上面代码可以看出，使用ValueAnimator实现动画，需要手动赋值给目标对象tvText的rotationY，而ObjectAnimator则是自动赋值，不需要手动赋值就可以达到效果。
动画过程可以通过AnimatorUpdateListener和AnimatorListener来监听。
 ObjectAnimator.ofFloat(tvText, "translationX", 0f, 780f, 0f).apply {
            duration=3000//完成动画所需要时间
            repeatCount=ValueAnimator.INFINITE  //重复次数：无限循环
            repeatMode=ValueAnimator.RESTART    //重复模式：重头开始
            addUpdateListener { //监听值变化
                tvText.translationX= it.animatedValue as Float
            }
            addListener(object:Animator.AnimatorListener{
                override fun onAnimationRepeat(animation: Animator?) {
                    //动画重复
                }

                override fun onAnimationEnd(animation: Animator?) {
                    //动画结束
                }

                override fun onAnimationCancel(animation: Animator?) {
                    //动画取消
                }

                override fun onAnimationStart(animation: Animator?) {
                    //动画开始
                }
            })
        }
复制代码动画可调用start()方法开始，也可调用cancel()方法取消。
那么，要正确使属性动画实现动画效果，那么目标对象应该注意什么？

属性必须具有 set<PropertyName>() 形式的 setter 函数（采用驼峰式大小写形式），例如，如果属性名称为 text，则需要使用 setText() 方法。
如果ObjectAnimator的一个工厂方法中仅为 values... 参数指定了一个值，那么该参数需要提供初始值和getPropertyName()方法。
属性的初始值和结束值之间必须保持类型相同。
可能需要在UpdateListener对象中调用invalidate() 方法，来刷新属性作用后的效果。

六、XML实现
本文一开始介绍位移属性动画时，有提到通过XML文件来实现动画效果，在这里进一步细讲。
在res/animator文件夹下，创建animator_translation.xml文件。XML文件有四个标签可用，要注意到propertyValuesHolder标签的Android 版本适配。
<?xml version="1.0" encoding="utf-8"?>
<set>   =>AnimatorSet
    <animator/>  =>ValueAnimator
    <objectAnimator>    =>ObjectAnimator
        <propertyValuesHolder/> =>PropertyValuesHolder
    </objectAnimator>
</set>
复制代码set标签对应代码的AnimatorSet,只有一个属性可以设置：android:ordering，取值：同时播放together、顺序播放sequentially。
animator标签对应代码的ValueAnimator，可以设置如下属性：

android:duration:动画时长
android:valueType:属性类型,intType、floatType、colorType、pathType
android:valueFrom:属性初始值
android:valueTo:属性结束值
android:repeatCount:重复次数
android:repeatMode:重复模式
android:interpolator:插值器，可看下一节默认插值器。
android:startOffset:延迟，对应startOffset()延迟多少毫秒执行

示例：
    <animator
        android:duration="1000"
        android:valueType="floatType"
        android:valueFrom="0f"
        android:valueTo="100f"
        android:repeatCount="infinite"
        android:repeatMode="restart"
        android:interpolator="@android:interpolator/linear"
        android:startOffset="100"
        />
复制代码objectAnimator属性对应代码ObjectAnimator,由于继承自ValueAnimator，所以属性相对多了` android:propertyName。
七、估值器与插值器
看到这里，不知道小伙伴们有没有这个疑问，属性动画是如何计算属性的值的？
这份工作由类型估值器TypeEvaluator与时间插值器TimeInterpolator来完成的。
插值器：根据时间流逝的百分比计算出当前属性值改变的百分比。
估值器：根据当前属性改变的百分比来计算改变后的属性值。
从它两的已定义，也可以看出它们之间的协调关系，先由插值器根据时间流逝的百分比计算出目标对象的属性改变的百分比，再由估值器根据插值器计算出来的属性改变的百分比计算出目标对象属性对应类型的值。
从估值器和插值器可以看出属性动画的工作原理，下面看看官方对工作原理的解析：

更多的原理可以看看链接
估值器
SDK中默认带有的估值器有：
IntEvaluator、FloatEvaluator、ArgbEvaluator，他们分别对应前面我们调用  ValueAnimator对象所有对应的ofInt、ofFloat、ofArgb函数的估值器，分别用在Int类型，Float，颜色值类型之间计算。而ofObject函数则对应我们自定义类型的属性计算。
当估值器的类型不满足需求，就需要自定义类型估值器。例如我们要实现下面效果：

这个效果可以通过AnimatorSet来实现，但我们这里采用自定义TypeEvaluator来实现TextView从屏幕左上角斜线滑到屏幕右下角。

定义Point类，我们操作的对象。

data class Point(var x: Float, var y: Float)
复制代码
定义PointEvaluator估值器，继承自TypeEvaluator,泛型参数为Point类型。通过实现evaluate()方法，可以实现很多复制的动画效果，我们这里实现上面简单算法。

class PointEvaluator : TypeEvaluator<Point> {
    /**
     * 根据插值器计算出当前对象的属性的百分比fraction,估算去属性当前具体的值
     * @param fraction 属性改变的百分比
     * @param startValue 对象开始的位置，例如这里点坐标开始位置：屏幕左上角位置
     * @param endValue 对象结束的位置，例如这里点坐标结束的位置:屏幕右下角位置
     */
    override fun evaluate(fraction: Float, startValue: Point?, endValue: Point?): Point {
        if (startValue == null || endValue == null) {
            return Point(0f, 0f)
        }

        return Point(
            fraction * (endValue.x - startValue.x),
            fraction * (endValue.y - startValue.y)
        )
    }
}
复制代码
使用

       val animator= ValueAnimator.ofObject(
            PointEvaluator(), 
            Point(0f, 0f),//动画开始属性值
            Point(
                ScreenUtils.getScreenWidth(this).toFloat(),
                ScreenUtils.getScreenHeight(this).toFloat()
            )//动画结束值
        )
        
        animator.addUpdateListener {//手动更新TextView的x和y 属性
            val point = it.animatedValue as Point
            tvText.x = point.x
            tvText.y = point.y 
            logError("point:${point}")
        }
        animator.duration = 5000

        btnStart.setOnClickListener {
            animator.start()
        }
复制代码一个简单的自定义估值器就算完成了。数学学的好，任何复杂效果都不是问题。
插值器
TypeEvaluator对象的evaluate()方法的fraction参数就是插值器计算得来，SDK中默认的时间插值器有：

LinearInterpolator 线性（匀速）
AccelerateInterpolator 持续加速
DecelerateInterpolator 持续减速
AccelerateDecelerateInterpolator 先加速后减速
OvershootInterpolator 结束时回弹一下
AnticipateInterpolator 开始回拉一下
BounceInterpolator 结束时Q弹一下
CycleInterpolator 来回循环

看看效果：
LinearInterpolator

AccelerateInterpolator

DecelerateInterpolator

AccelerateDecelerateInterpolator

OvershootInterpolator

AnticipateInterpolator

BounceInterpolator

CycleInterpolator

正常情况下，默认的插值器已经够用，如果自己数学厉害，想显摆一下，也是通过实现TimeInterpolator接口的getInterpolation()自定义的。
/**
 * A time interpolator defines the rate of change of an animation. This allows animations
 * to have non-linear motion, such as acceleration and deceleration.
 */
public interface TimeInterpolator {

    /**
     * Maps a value representing the elapsed fraction of an animation to a value that represents
     * the interpolated fraction. This interpolated value is then multiplied by the change in
     * value of an animation to derive the animated value at the current elapsed animation time.
     *
     * @param input A value between 0 and 1.0 indicating our current point
     *        in the animation where 0 represents the start and 1.0 represents
     *        the end
     * @return The interpolation value. This value can be more than 1.0 for
     *         interpolators which overshoot their targets, or less than 0 for
     *         interpolators that undershoot their targets.
     */
    float getInterpolation(float input);
}
复制代码八、Keyframe
要控制动画速率的变化，就得去自定义插值器或估值器，对我这种数学渣渣来说，简直比上天一样难的。
所以渣渣们可以考虑用关键帧Keyframe对象来实现。Keyframe让我们可以指定某个属性百分比时对象的属性值。
    tvText.setOnClickListener {
        val start = Keyframe.ofFloat(0f, 0f)
        val middle = Keyframe.ofFloat(0.3f, 400f)
        val end = Keyframe.ofFloat(1f, 700f)
        val holder=PropertyValuesHolder.ofKeyframe("translationX",start,middle,end)
        ObjectAnimator.ofPropertyValuesHolder(tvText,holder).apply {
            duration=2000
            start()
        }
    }
复制代码上面代码分别定义了三个关键帧，分别在属性百分比为0f、0.3f、1f对应的translationX的值。
动画效果：

可以看到效果先快后慢。
Keyframe同样支持ofFloat、ofInt、ofObject。使用关键帧，至少需要有两个关键帧，不然坐等奔溃吧。PropertyValuesHolder对象是用来保存动画过程所操作的属性和对应的值。
九、总结
通过ObjectAnimator的工厂方法可以快速实现一个属性动画，但默认的属性动画不满足自己的需求是，可以通过ValueAnimator对象来定义自己的属性，注意属性的要求。可以通过AnimatorSet来实现属性组合播放效果。
动画的原理是通过时间插值器与类型估值器配置使用，控制对象的属性来实现动画效果。

作者：新小梦
链接：https://juejin.cn/post/6846687601118691341
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

