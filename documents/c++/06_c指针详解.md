## 一、细说指针
指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：
- 指针的类型
- 指针所指向的类型
- 指针的值或者叫指针所指向的内存区、
- 指针本身所占据的内存区。

### 1、指针的类型

从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。
```c
(1)int *ptr; // 指针的类型是 int*
(2)char *ptr; // 指针的类型是 char*
(3)int **ptr; // 指针的类型是 int**
(4)int (*ptr)[3];// 指针的类型是 int(*)[3]
(5)int *(*ptr)[4];// 指针的类型是 int*(*)[4]
```
### 2、指针指向的类型

当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。

从语法上看，你只须把指针声明语句中的`指针名字和名字左边的指针声明符 *`去掉，剩下的就是指针所指向的类型。
```c
(1)int *ptr; // 指针所指向的类型是 int
(2)char *ptr; // 指针所指向的的类型是 char
(3)int **ptr; // 指针所指向的的类型是 int*
(4)int (*ptr)[3]; // 指针所指向的的类型是 int()[3]
(5)int *(*ptr)[4]; // 指针所指向的的类型是 int*()[4]
```

### 3、指针的值（指针所指向的内存区或地址）

指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在 32 位程序里，所有类型的指针的值都是一个32 位整数，因为 32 位程序里内存地址全都是 32 位长。
指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为 `sizeof(指针所指向的类型)` 的一片内存区。

### 4、指针本身所占据的内存区

指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用。

## 二、指针的算术运算

指针的算术运算和通常的数值的加减运算的意义是不一样的，指针的运算是以单元为单位进行的。

```c
char a[20];  
int *ptr=(int *)a; //强制类型转换并不会改变 a 的类型  
ptr++;  
```
在上例中，指针 ptr 的类型是`int*`,它指向的类型是`int`，它被初始化为指向整型变量 a。
`ptr++` 把指针 ptr 的值加上了 sizeof(int)，在 32 位程序中，是被加上了 4，因为在32 位程序中，int 占 4 个字节。
由于地址是用字节做单位的，故 ptr 所指向的地址由原来的 变量a 的地址向高地址方向增加了4 个字节。
由于char 类型的长度是一个字节，所以，原来 ptr 是指向数组a的第0号单元开始的四个字节，此时指向了数组a中从第4号单元开始的四个字节。

我们可以用一个指针和一个循环来遍历一个数组，看例子：

```c
int array[20]={0};  
int *ptr = array;  
for(i=0;i<20;i++)  
{  
    (*ptr)++;  
    ptr++；  
}  
```
这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1 个单元，所以每次循环都能访问数组的下一个单元。


## 三、运算符`&和*`

`&`是取址符，`*`是间接运算符。
`&a` 的运算结果是一个指针，指针的类型是 a 的类型加个`*`，指针所指向的类型是 `a` 的类型，指针所指向的地址是 `a` 的地址。
`*p` 的结果是 p 所指向的东西

```c
int a=12; 
int b; 
int *p; 
int **ptr;  
p=&a;  //&a 的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a 的地址。 
*p=24; //*p 的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，*p就是变量a。 
ptr=&p; //&p 的结果是个指针，该指针的类型是p 的类型加个*，  在这里是int **。该指针所指向的类型是p 的类型，这里是int*。该指针所指向的地址就是指针p 自己的地址。 
*ptr=&b; //*ptr 是个指针，&b 的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以用&b 来给*ptr 赋  值就是毫无问题的了。  
**ptr=34;  // *ptr 的结果是 ptr 所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果是一个 int 类型的变量。 
```

## 四、指针和数组

数组的数组名其实可以看作一个指针。

```c
int array[10]={0,1,2,3,4,5,6,7,8,9},value;  
value = array[0]; //也可写成：value=*array;  
value = array[3]; //也可写成：value=*(array+3); 

int *pa = array;  
*pa; //访问了第0 号单元  
*(pa+1); //访问了第1 号单元  
```
上例中，一般而言数组名 `array` 代表数组本身，类型是`int[10]`，但如果把 array 看做指针的话，它指向数组的第 0 个单元，类型是 `int*` 所指向的类型是数组单元的类型即 `int`。

```c
int array[10];  
int (*ptr)[10];  
ptr = &array;
```
上例中 ptr 是一个指针，它的类型是`int(*)[10]`，指向的类型是`int[10]`，我们用整个数组的首地址来初始化它。在语句 ptr=&array 中，array 代表数组本身。

## 五、指针和结构体
可以声明一个指向结构类型对象的指针。

```c
struct MyStruct  
{  
    int a;  
    int b;  
    int c;  
};
struct MyStruct ss={20,30,40}; 
struct MyStruct *ptr=&ss; 声明了一个指向结构对象ss 的指针。    
```
请通过指针ptr 来访问ss 的三个成员变量
```c
ptr->a; //指向运算符，或者可以这们(*ptr).a,建议使用前者
ptr->b;
ptr->c;
```

## 六、指针和函数
可以把一个指针声明成为一个指向函数的指针。
```c
int fun1(char *,int);
int (*pfun1)(char *,int);
pfun1 = fun1;
int a = (*pfun1)("abcdefg",7); //通过函数指针调用函数。
```
可以把指针作为函数的形参。

在函数调用语句中，可以用指针表达式来作为实参。
```c
int fun(char *);  
int a;  
char str[]="abcdefghijklmn";  
a = fun(str);  
int fun(char *s)  
{  
    int num=0;  
    for(int i=0;;)  
    {  
        num+=*s;s++;  
    }  
    return num;  
}  
```
这个例子中的函数 fun 统计一个字符串中各个字符的 ASCII 码值之和。

## 七、指针类型转换
当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。
```c
float f = 12.3;  
float *fptr = &f;  
int *p = (int*)&f; // 不能直接赋值，要经过类型强转
```
这样强制类型转换的结果是一个新指针，该新指针的类型是 `TYPE *`，它指向的类型是 `TYPE`，它指向的地址就是原指针指向的地址。**而原来的指针p 的一切属性都没有被修改。（切记）**

利用强转我们还可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针。

## 八、指针的安全问题
```c
char s='a';  
int *ptr;  
ptr=(int *)&s;  
*ptr=1298；
```
指针 ptr 是一个`int*`类型的指针，它指向的类型是`int`。它指向的地址就是 s 的首地址。在 32 位程序中，s 占一个字节，int 类型占四个字节。
最后一条语句不但改变了 s 所占的一个字节，还把和 s 相临的高地址方向的三个字节也改变了。

## 九、简答的指针例子

一个类型里会出现很多运算符，他们也像普通的表达式一样，有优先级。
其优先级和运算优先级一样。所以我总结了一下其原则：**从变量名处起，根据运算符优先级结合，一步一步分析**。

1）这是一个普通的**整型变量**
```c
int p; 
```

2）首先从 `P` 处开始,先与 `*` 结合，所以说明 P 是一个指针。然后再与 `int` 结合，说明 P 所指向的类型为`int`。所以 `P` 是一个 `指向整型数据的指针`   
```c
int *p; 
```

3）首先从 `P` 处开始,先与 `[]` 结合，说明 `P` 是一个数组，然后与 `int` 结合，说明数组里的元素是整型的，所以 `P` 是一个**由整型数据组成的数组**  
```c
int p[3];
```

4）首先从 `P` 处开始,先与 `[]` 结合，因为其优先级比 `*` 高，所以 `P` 是一个数组。然后再与 `*` 结合，说明数组里的元素类型是指针，然后再与 `int` 结合，说明 P 是一个**由型数指针所组成的数组** 
```c
int *p[3]; 
```

5）首先从 `P` 处开始，先与 `*` 结合，说明 `P` 是一个指针。然后再与 `[]` 结合，说明 P 所指向的内容是一个数组，然后再与 `int` 结合，说明数组里的元素类型是整型。所以 P 是一个**整型数据组成的数组的指针** 。
```c  
int (*p)[3];
```

6）首先从 `P` 开始，先与 `*` 结合，说是 `P` 是一个指针。然后再与 `*` 结合，说明 P 所指向的类型也是指针。然后再与 `int` 结合，说明 P 指向的元素是`指向int类型的指针`。
```c
int **p;
```
7）从 P 处起,先与 () 结合，说明 P 是一个函数，然后进入 () 里分析，说明该函数有一个整型变量的参数。然后再与外面的 int 结合，说明函数的返回值是一个整型数据 。
```c
int p(int); 
```

8）从 P 处开始,先与指针结合，说明P 是一个指针，然后与()结合，说明 P 指向的是一个函数。然后再与 `()` 里的 `int` 结合，说明函数有一个 int 型的参数,再与最外层的int 结合，说明函数的返回类型是整型。所以 P 是一个指向有一个整型参数且返回类型为整型的函数的指针
```c
int (*p)(int);  
```
可以先跳过，不看这个类型。从 P 开始,先与()结合，说明P 是一个函数，然后进入 `()` 里面，与 `int` 结合，说明函数有一个整型变量参数。
然后再与外面的`*`结合，说明函数返回的是一个指针。然后到最外面一层，先与[]结合,说明返回的指针指向的是一个数组。
然后再与`*`结合，说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数. 
```c
int *(*p(int))[3]; 
```


