
|代号	|版本	|API 级别/NDK 版本|
|  ----  | ----  |----  |
|Android11	|11	|API 级别 30|
|Android10	|10	|API 级别 29|
|Pie	|9	|API 级别 28|
|Oreo	|8.1.0	|API 级别 27|
|Oreo	|8.0.0	|API 级别 26|
|Nougat	|7.1	|API 级别 25|
|Nougat	|7.0	|API 级别 24|
|Marshmallow	|6.0	|API 级别 23|
|Lollipop	|5.1	|API 级别 22|
|Lollipop	|5.0	|API 级别 21|
|KitKat	|4.4 - 4.4.4	|API 级别 19|
|Jelly Bean	|4.3.x	|API 级别 18|
|Jelly Bean	|4.2.x	|API 级别 17|
|Jelly Bean	|4.1.x	|API 级别 16|

### 5.0

Material Theme

Z轴，阴影。

ART虚拟机

### 6.0

应用权限管理

官方指纹支持

Doze电量管理

运行时权限机制->需要动态申请权限

### 7.0

多窗口模式

支持Java 8语言平台

#### 需要使用FileProvider访问照片

Android 7.0 之前，文件的 Uri 以 file:/// 形式提供给其他app访问。

Android 7.0 之后，分享文件的Uri发生了变化。为了安全起见，file:/// 形式的Uri不能正常访问。

官方提供了 FileProvider，FileProvider 生成的 Uri 会以 content:// 的形式分享给其他app使用。

content形式的Uri可以让其他app临时获得读取(Read)和写入(Write)权限，只要我们在创建 Intent 时，使用 Intent.setFlags() 添加权限。

只要接收 Uri 的 app 在接收的 Activity 任务栈中处于活动状态，添加的权限就会一直有效，直到 app 被任务栈移除。

```html
<provider
    android:name="androidx.core.content.FileProvider"
    android:authorities="包名.fileprovider"
    android:exported="false" <!--是否到处 -->
    android:grantUriPermissions="true"> <!--是否可以设置权限 -->
    <meta-data
        android:name="android.support.FILE_PROVIDER_PATHS"
        android:resource="@xml/file_paths" />
</provider>
```

resources 下面新建 xml 文件夹，新建 filepaths 文件。

```html
<?xml version="1.0" encoding="utf-8"?>
<paths>
    <!--物理路径相当于Context.getFilesDir() + /path/。-->
    <!--<files-path name="name" path="path" />-->

    <!--物理路径相当于Context.getCacheDir() + /path/。-->
    <!--<cache-path name="name" path="path" />-->

    <!--物理路径相当于Environment.getExternalStorageDirectory() + /path/。-->
    <!--<external-path name="name" path="path" />-->

    <!--物理路径相当于Context.getExternalFilesDir(String) + /path/。-->
    <!--<external-files-path name="name" path="path" />-->

    <!--物理路径相当于Context.getExternalCacheDir() + /path/。-->
    <!--<external-cache-path name="name" path="path" />-->
      
    <cache-path  
         name="imgs_dir"
         path="imgs" />
<!--     <files-path
        name="logs_dir"
        path="logs" /> -->
    <!-- 可以在path中用.代替所有目录 -->
    <files-path
        name="files"
        path="." />
</paths>
```

**使用**

```koltin
val logsDir = File(mContext.filesDir, "logs")
if (!logsDir.exists()) {
    logsDir.mkdirs()
}
val logFile = File(logsDir, "native.log")
if (!logFile.exists()) {
    logFile.createNewFile()
}
val logUri: Uri = FileProvider.getUriForFile(
    mContext,
    BuildConfig.APPLICATION_ID + ".fileprovider", logFile
)
Log.e("storage", logUri.toString())

//cache 目录
val imgsDir = File(mContext.cacheDir, "imgs")
if (!imgsDir.exists()) {
    imgsDir.mkdirs()
}
val headImg = File(imgsDir, "head.png")
if (!headImg.exists()) {
    headImg.createNewFile()
}
val imgUri: Uri = FileProvider.getUriForFile(
    mContext,
    BuildConfig.APPLICATION_ID + ".fileprovider", headImg
)
Log.e("storage", imgUri.toString())


Intent intent = new Intent(Intent.ACTION_SEND);
intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
// 邮箱分享文件
intent.putExtra(Intent.EXTRA_STREAM, contentUri);
// Intent.setDate或Intent.setClipData()
inetnt.setClipData.newRawUri("", contentUri)
```

安装apk需要兼容

### 8.0

通知

画中画

自动填充

后台限制

自适应桌面图标->适配

隐式广播限制

开启后台Service限制

### 9.0

利用 Wi-Fi RTT 进行室内定位

刘海屏 API 支持

多摄像头支持和摄像头更新

不允许调用hide api

限制明文流量的网络请求 http

### 10

暗黑模式

隐私增强(后台能否访问定位)

限制程序访问剪贴板

应用黑盒

权限细分需兼容

后台定位单独权限需兼容

设备唯一标示符需兼容

后台打开Activity 需兼容

非 SDK 接口限制 需兼容
