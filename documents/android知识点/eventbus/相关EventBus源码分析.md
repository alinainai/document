### 1. 简单使用

[官方地址: https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)

<img width="400" alt="类图" src="https://user-images.githubusercontent.com/17560388/163953816-f7cfffd7-e2a2-4fc9-aa11-d88fe7102600.png">


添加依赖

```groovy
implementation("org.greenrobot:eventbus:3.3.1")
```
使用
```java
// 1. 定义事件 和 事件接收的方法
public static class MessageEvent { /* Additional fields if needed */ }

@Subscribe(threadMode = ThreadMode.MAIN)  
public void onMessageEvent(MessageEvent event) {
    // Do something
}

// 2. 在 Activity 或者 Fragment 中注册和反注册
@Override
public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
}
@Override
public void onStop() {
    super.onStop();
    EventBus.getDefault().unregister(this);
}

// 3. 发送事件
EventBus.getDefault().post(new MessageEvent());
```

#### 3.0之后的优化：使用 Subscriber Index

[Subscriber Index](https://greenrobot.org/eventbus/documentation/subscriber-index/)

生成 Index

```groovy
apply plugin: 'kotlin-kapt' // ensure kapt plugin is applied
 
dependencies {
    def eventbus_version = '3.2.0'
    implementation "org.greenrobot:eventbus:$eventbus_version"
    kapt "org.greenrobot:eventbus-annotation-processor:$eventbus_version"
}
 
kapt {
    arguments {
        arg('eventBusIndex', 'com.eventbus.project.MyEventBusIndex') //包名可以根据自身项目更改
    }
}
```
重新 build 项目，在对应的 build 目录下会生成 MyEventBusIndex 对象。

```java
/** This class is generated by EventBus, do not edit. */
public class MyEventBusIndex implements SubscriberInfoIndex {
    // 缓存 Class 和 SubscriberInfo 的容器
    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;

    static {
        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();
        // 将 class 和 SubscriberMethods 的对应关系添加到缓存容器中
        putIndex(new SimpleSubscriberInfo(com.mihua.ljxbao.ui.splash.Test1Activity.class, true,
                new SubscriberMethodInfo[] {
            new SubscriberMethodInfo("onMessageEvent", com.mihua.ljxbao.ui.splash.MessageEvent.class, ThreadMode.MAIN),
        }));

    }

    private static void putIndex(SubscriberInfo info) {
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }

    //通过注册类获取类对应的 SubscriberInfo
    @Override
    public SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}
```
#### 两种方式怎么样使用 index

Then, e.g. in your Application class, use EventBus.builder().addIndex(indexInstance) to pass an instance of the index class to EventBus.
```java
EventBus eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build();
```
Use EventBusBuilder.installDefaultEventBus() to set the EventBus with index as the instance returned by EventBus.getDefault().
```java
EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();
// Now the default instance uses the given index. Use it like this:
EventBus eventBus = EventBus.getDefault();
```
我觉得第二种比较不错，赋值之后直接使用 getDefault()

### 2. 源码分析

咱们按照使用顺序去追踪一下源码

#### 1. 注册  EventBus.getDefault().register(this)

```java
public void register(Object subscriber) {

    if (AndroidDependenciesDetector.isAndroidSDKAvailable() && !AndroidDependenciesDetector.areAndroidComponentsAvailable()) {
        // Crash if the user (developer) has not imported the Android compatibility library.  对Android 是否导入做检测
        throw new RuntimeException("It looks like you are using EventBus on Android, " +
                "make sure to add the \"eventbus\" Android library to your dependencies.");
    }
    //获取 subscriber 对象的 Class 
    Class<?> subscriberClass = subscriber.getClass();
    // 查找 subscriberClass 中所有可以接收 event 消息的方法存入 List，后面具体分析
    List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
    synchronized (this) {
        for (SubscriberMethod subscriberMethod : subscriberMethods) {
            subscribe(subscriber, subscriberMethod);
        }
    }   
}
```

先简单看一下 SubscriberMethod 类和它的参数，这个类是对 register(class) 类中的 @Subscribe 方法的包装

```java
public class SubscriberMethod {
    final Method method;
    final ThreadMode threadMode; //方法执行的线程标志
    final Class<?> eventType; //事件的类型
    final int priority; //优先级
    final boolean sticky; //是否是粘性事件，粘性事件
```

我们继续追踪 SubscriberMethodFinder # findSubscriberMethods(subscriberClass) 来看下 List<SubscriberMethod> 是怎么查找的

```java 
List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
    // 先查看 METHOD_CACHE 中是否已经存储过，是对 subscriberClass 和对应 List<SubscriberMethod> 一个缓存优化
    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
    if (subscriberMethods != null) {
        return subscriberMethods;
    }
    // ignoreGeneratedIndex 属性表示是否忽略注解器生成的 MyEventBusIndex。
    // ignoreGeneratedIndex 的默认值为 false，可以在 EventBus初始化的时候通过 EventBusBuilder 来设置它的值
    if (ignoreGeneratedIndex) {
        //通过反射的形式获取
        subscriberMethods = findUsingReflection(subscriberClass);
    } else {
        subscriberMethods = findUsingInfo(subscriberClass);
    }
    if (subscriberMethods.isEmpty()) { 
        //如果注册的类中没有 SubscriberMethod 方法，直接抛出有异常
        throw new EventBusException("Subscriber " + subscriberClass
                + " and its super classes have no public methods with the @Subscribe annotation");
    } else { 
        //保存并返回 List<SubscriberMethod> 对象
        METHOD_CACHE.put(subscriberClass, subscriberMethods);
        return subscriberMethods;
    }
}
```



