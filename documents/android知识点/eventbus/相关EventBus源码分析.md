### 1. 简单使用

[官方地址: https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)

<img width="400" alt="类图" src="https://user-images.githubusercontent.com/17560388/163953816-f7cfffd7-e2a2-4fc9-aa11-d88fe7102600.png">


添加依赖

```groovy
implementation("org.greenrobot:eventbus:3.3.1")
```
#### 1.1 简单使用
```java
// 1. 定义事件 和 事件接收的方法
public static class MessageEvent { /* Additional fields if needed */ }

@Subscribe(threadMode = ThreadMode.MAIN)  
public void onMessageEvent(MessageEvent event) {
    // Do something
}

// 2. 在 Activity 或者 Fragment 中注册和反注册
@Override
public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
}
@Override
public void onStop() {
    super.onStop();
    EventBus.getDefault().unregister(this);
}

// 3. 发送事件
EventBus.getDefault().post(new MessageEvent());
```

#### 1.2 进阶使用

3.0之后的优化：使用 Subscriber Index

[Subscriber Index](https://greenrobot.org/eventbus/documentation/subscriber-index/)

生成 Index

```groovy
apply plugin: 'kotlin-kapt' // ensure kapt plugin is applied
 
dependencies {
    def eventbus_version = '3.2.0'
    implementation "org.greenrobot:eventbus:$eventbus_version"
    kapt "org.greenrobot:eventbus-annotation-processor:$eventbus_version"
}
 
kapt {
    arguments {
        arg('eventBusIndex', 'com.eventbus.project.MyEventBusIndex') //包名可以根据自身项目更改
    }
}
```
重新 build 项目，在对应的 build 目录下会生成 MyEventBusIndex 对象。

```java
/** This class is generated by EventBus, do not edit. */
public class MyEventBusIndex implements SubscriberInfoIndex {
    // 缓存 Class 和 SubscriberInfo 的容器
    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;

    static {
        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();
        // 将 class 和 SubscriberMethods 的对应关系包装为 SubscriberInfo 并添加到缓存容器中
        putIndex(new SimpleSubscriberInfo(com.mihua.ljxbao.ui.splash.Test1Activity.class, true,
                new SubscriberMethodInfo[] {
            new SubscriberMethodInfo("onMessageEvent", com.mihua.ljxbao.ui.splash.MessageEvent.class, ThreadMode.MAIN),
        }));

    }

    private static void putIndex(SubscriberInfo info) {
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }

    //通过注册类获取类对应的 SubscriberInfo
    @Override
    public SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}
```
#### 两种方式怎么样使用 index

Then, e.g. in your Application class, use EventBus.builder().addIndex(indexInstance) to pass an instance of the index class to EventBus.
```java
EventBus eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build();
```
Use EventBusBuilder.installDefaultEventBus() to set the EventBus with index as the instance returned by EventBus.getDefault().
```java
EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();
// Now the default instance uses the given index. Use it like this:
EventBus eventBus = EventBus.getDefault();
```
我觉得第二种比较不错，赋值之后直接使用 getDefault()

### 2. 源码分析

咱们按照使用顺序去追踪一下源码

#### 1. 注册  EventBus.getDefault().register(this)

```java
public void register(Object subscriber) {

    if (AndroidDependenciesDetector.isAndroidSDKAvailable() && !AndroidDependenciesDetector.areAndroidComponentsAvailable()) {
        // Crash if the user (developer) has not imported the Android compatibility library.  对Android 是否导入做检测
        throw new RuntimeException("It looks like you are using EventBus on Android, " +
                "make sure to add the \"eventbus\" Android library to your dependencies.");
    }
    //获取 subscriber 对象的 Class 
    Class<?> subscriberClass = subscriber.getClass();
    // 查找 subscriberClass 中所有可以接收 event 消息的方法存入 List，后面具体分析
    List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
    synchronized (this) {
        for (SubscriberMethod subscriberMethod : subscriberMethods) {
            subscribe(subscriber, subscriberMethod);
        }
    }   
}
```

先简单看一下 SubscriberMethod 类和它的参数，这个类是对 register(class) 类中的 @Subscribe 方法的包装

```java
public class SubscriberMethod {
    final Method method;
    final ThreadMode threadMode; //方法执行的线程标志
    final Class<?> eventType; //事件的类型
    final int priority; //优先级
    final boolean sticky; //是否是粘性事件，粘性事件
```

我们继续追踪 `SubscriberMethodFinder#findSubscriberMethods(subscriberClass)` 方法，来看下 List<SubscriberMethod> 是怎么查找的

```java 
List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
    // 先查看 METHOD_CACHE 中是否已经存储过，是对 subscriberClass 和对应 List<SubscriberMethod> 一个缓存优化
    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
    if (subscriberMethods != null) {
        return subscriberMethods;
    }
    // ignoreGeneratedIndex 属性表示是否忽略注解器生成的 MyEventBusIndex，默认为false，可以通过 EventBusBuilder 来设置它的值
    if (ignoreGeneratedIndex) {
        //通过反射的形式获取
        subscriberMethods = findUsingReflection(subscriberClass);
    } else {
        subscriberMethods = findUsingInfo(subscriberClass);
    }
    if (subscriberMethods.isEmpty()) { 
        //如果注册的类中没有 SubscriberMethod 方法，直接抛出有异常
        throw new EventBusException("Subscriber " + subscriberClass
                + " and its super classes have no public methods with the @Subscribe annotation");
    } else { 
        //保存并返回 List<SubscriberMethod> 对象
        METHOD_CACHE.put(subscriberClass, subscriberMethods);
        return subscriberMethods;
    }
}
```

再来看下`SubscriberMethodFinder#findSubscriberMethods(subscriberClass)` 方法，该方法比较简单。

```java
private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
    FindState findState = prepareFindState(); //
    findState.initForSubscriber(subscriberClass);
    while (findState.clazz != null) {
        //核心方法，下面分析
        findUsingReflectionInSingleClass(findState);
        findState.moveToSuperclass(); //继续搜寻父类中的 @Subscriber 方法
    }
    return getMethodsAndRelease(findState); // 释放 FindState 对象到对象池
}
```
    
`SubscriberMethodFinder#prepareFindState()` 里面有个不错的知识点，采用对象池的方式缓存 FindState 对象。
    
```java
//对象池
private static final int POOL_SIZE = 4;
private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
//从对象池中获取 FindState 对象，没有的话就新建一个 FindState
private FindState prepareFindState() {
    synchronized (FIND_STATE_POOL) {
        for (int i = 0; i < POOL_SIZE; i++) {
            FindState state = FIND_STATE_POOL[i];
            if (state != null) {
                FIND_STATE_POOL[i] = null;
                return state;
            }
        }
    }
    return new FindState();
}
//使用完成之后将 FindState recycle , 并存储到 对象池中
private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
    List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
    findState.recycle();
    synchronized (FIND_STATE_POOL) {
        for (int i = 0; i < POOL_SIZE; i++) {
            if (FIND_STATE_POOL[i] == null) {
                FIND_STATE_POOL[i] = findState;
                break;
            }
        }
    }
    return subscriberMethods;
}
```
再来看下 `SubscriberMethodFinder#findUsingInfo(subscriberClass)` 方法。
```java                                                                    
private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
    FindState findState = prepareFindState();
    findState.initForSubscriber(subscriberClass);
    while (findState.clazz != null) {
        findState.subscriberInfo = getSubscriberInfo(findState);
        if (findState.subscriberInfo != null) {
            // subscriberInfo 不为空，直接从 subscriberInfo 获取 SubscriberMethods
            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
            for (SubscriberMethod subscriberMethod : array) {
                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
                    findState.subscriberMethods.add(subscriberMethod);
                }
            }
        } else {
            findUsingReflectionInSingleClass(findState);
        }
        findState.moveToSuperclass();
    }
    return getMethodsAndRelease(findState);
}                                                                       
```  
这个方法主要是处理咱们上面讲过的 3.0+ 版本使用 Index 对 EventBus 的优化。先查询能不能获取到 subscriberClass 对用的 SubscriberInfo 对象，然后从 SubscriberInfo 中获取 SubscriberMethod 的集合。

                                                                      
再看下 `SubscriberMethodFinder#findUsingReflectionInSingleClass(findState)` 方法

```java
private void findUsingReflectionInSingleClass(FindState findState) {
    Method[] methods;
    try {
        // This is faster than getMethods, especially when subscribers are fat classes like Activities
        methods = findState.clazz.getDeclaredMethods();
    } catch (Throwable th) {
        // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
        try {
            methods = findState.clazz.getMethods();
        } catch (LinkageError error) { // super class of NoClassDefFoundError to be a bit more broad...
            String msg = "Could not inspect methods of " + findState.clazz.getName();
            if (ignoreGeneratedIndex) {
                msg += ". Please consider using EventBus annotation processor to avoid reflection.";
            } else {
                msg += ". Please make this class visible to EventBus annotation processor to avoid reflection.";
            }
            throw new EventBusException(msg, error);
        }
        findState.skipSuperClasses = true;
    }
    // 上面是获取 subscriberClass 中的所有方法
    for (Method method : methods) {
        int modifiers = method.getModifiers();
        if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
            Class<?>[] parameterTypes = method.getParameterTypes();
            if (parameterTypes.length == 1) {
                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                //将有 @Subscribe 注解的方法和注解中参数生成一个 SubscriberMethod 对象，并添加到集合中
                if (subscribeAnnotation != null) {
                    Class<?> eventType = parameterTypes[0];
                    if (findState.checkAdd(method, eventType)) {
                        ThreadMode threadMode = subscribeAnnotation.threadMode();
                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                    }
                }
            } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
                String methodName = method.getDeclaringClass().getName() + "." + method.getName();
                throw new EventBusException("@Subscribe method " + methodName +
                        "must have exactly 1 parameter but has " + parameterTypes.length);
            }
        } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
            String methodName = method.getDeclaringClass().getName() + "." + method.getName();
            throw new EventBusException(methodName +
                    " is a illegal @Subscribe method: must be public, non-static, and non-abstract");
        }
    }
 }
```
findUsingReflectionInSingleClass 方法通过反射的方式查找 subscriberClass 中的 SubscriberMethod 方法并添加到集合中

查找 List<SubscriberMethod> 的过程到这里就结束了，下面我们看下 `EventBus#register(subsricberClass)` 中调用的 `subscribe` 方法

```java
// Must be called in synchronized block
private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
    Class<?> eventType = subscriberMethod.eventType; //获取 subscriberMethod 的事件类型
    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
    CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
    if (subscriptions == null) {
        subscriptions = new CopyOnWriteArrayList<>();
        subscriptionsByEventType.put(eventType, subscriptions);
    } else {
        if (subscriptions.contains(newSubscription)) {
            throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
                    + eventType);
        }
    }

    int size = subscriptions.size();
    for (int i = 0; i <= size; i++) {
        if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
            subscriptions.add(i, newSubscription);
            break;
        }
    }

    List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
    if (subscribedEvents == null) {
        subscribedEvents = new ArrayList<>();
        typesBySubscriber.put(subscriber, subscribedEvents);
    }
    subscribedEvents.add(eventType);

    if (subscriberMethod.sticky) {
        if (eventInheritance) {
            // Existing sticky events of all subclasses of eventType have to be considered.
            // Note: Iterating over all events may be inefficient with lots of sticky events,
            // thus data structure should be changed to allow a more efficient lookup
            // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
            Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
            for (Map.Entry<Class<?>, Object> entry : entries) {
                Class<?> candidateEventType = entry.getKey();
                if (eventType.isAssignableFrom(candidateEventType)) {
                    Object stickyEvent = entry.getValue();
                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                }
            }
        } else {
            Object stickyEvent = stickyEvents.get(eventType);
            checkPostStickyEventToSubscription(newSubscription, stickyEvent);
        }
    }
}
```
### 参考

[EventBus索引分析](https://www.jianshu.com/p/25388d6446bf)

[第三方开源库 EventBus - 源码分析和手写](https://www.jianshu.com/p/0b35f448acec)
