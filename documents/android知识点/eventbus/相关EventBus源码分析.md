### 1. 简单使用

[官方地址: https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)

<img width="400" alt="类图" src="https://user-images.githubusercontent.com/17560388/163953816-f7cfffd7-e2a2-4fc9-aa11-d88fe7102600.png">


添加依赖

```groovy
implementation("org.greenrobot:eventbus:3.3.1")
```
使用
```java
// 1. 定义事件 和 事件接收的方法
public static class MessageEvent { /* Additional fields if needed */ }

@Subscribe(threadMode = ThreadMode.MAIN)  
public void onMessageEvent(MessageEvent event) {
    // Do something
}

// 2. 在 Activity 或者 Fragment 中注册和反注册
@Override
public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
}
@Override
public void onStop() {
    super.onStop();
    EventBus.getDefault().unregister(this);
}

// 3. 发送事件
EventBus.getDefault().post(new MessageEvent());
```

#### 3.0之后的优化：使用 Subscriber Index

[Subscriber Index](https://greenrobot.org/eventbus/documentation/subscriber-index/)

生成 Index

```groovy
apply plugin: 'kotlin-kapt' // ensure kapt plugin is applied
 
dependencies {
    def eventbus_version = '3.2.0'
    implementation "org.greenrobot:eventbus:$eventbus_version"
    kapt "org.greenrobot:eventbus-annotation-processor:$eventbus_version"
}
 
kapt {
    arguments {
        arg('eventBusIndex', 'com.eventbus.project.MyEventBusIndex') //包名可以根据自身项目更改
    }
}
```
重新 build 项目，在对应的 build 目录下会生成 MyEventBusIndex 对象。

```java
/** This class is generated by EventBus, do not edit. */
public class MyEventBusIndex implements SubscriberInfoIndex {
    // 缓存 Class 和 SubscriberInfo 的容器
    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;

    static {
        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();
        // 将 class 和 SubscriberMethods 的对应关系包装为 SubscriberInfo 并添加到缓存容器中
        putIndex(new SimpleSubscriberInfo(com.mihua.ljxbao.ui.splash.Test1Activity.class, true,
                new SubscriberMethodInfo[] {
            new SubscriberMethodInfo("onMessageEvent", com.mihua.ljxbao.ui.splash.MessageEvent.class, ThreadMode.MAIN),
        }));

    }

    private static void putIndex(SubscriberInfo info) {
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }

    //通过注册类获取类对应的 SubscriberInfo
    @Override
    public SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}
```
#### 两种方式怎么样使用 index

Then, e.g. in your Application class, use EventBus.builder().addIndex(indexInstance) to pass an instance of the index class to EventBus.
```java
EventBus eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build();
```
Use EventBusBuilder.installDefaultEventBus() to set the EventBus with index as the instance returned by EventBus.getDefault().
```java
EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();
// Now the default instance uses the given index. Use it like this:
EventBus eventBus = EventBus.getDefault();
```
我觉得第二种比较不错，赋值之后直接使用 getDefault()

### 2. 源码分析

咱们按照使用顺序去追踪一下源码

#### 1. 注册  EventBus.getDefault().register(this)

```java
public void register(Object subscriber) {

    if (AndroidDependenciesDetector.isAndroidSDKAvailable() && !AndroidDependenciesDetector.areAndroidComponentsAvailable()) {
        // Crash if the user (developer) has not imported the Android compatibility library.  对Android 是否导入做检测
        throw new RuntimeException("It looks like you are using EventBus on Android, " +
                "make sure to add the \"eventbus\" Android library to your dependencies.");
    }
    //获取 subscriber 对象的 Class 
    Class<?> subscriberClass = subscriber.getClass();
    // 查找 subscriberClass 中所有可以接收 event 消息的方法存入 List，后面具体分析
    List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
    synchronized (this) {
        for (SubscriberMethod subscriberMethod : subscriberMethods) {
            subscribe(subscriber, subscriberMethod);
        }
    }   
}
```

先简单看一下 SubscriberMethod 类和它的参数，这个类是对 register(class) 类中的 @Subscribe 方法的包装

```java
public class SubscriberMethod {
    final Method method;
    final ThreadMode threadMode; //方法执行的线程标志
    final Class<?> eventType; //事件的类型
    final int priority; //优先级
    final boolean sticky; //是否是粘性事件，粘性事件
```

我们继续追踪 `SubscriberMethodFinder#findSubscriberMethods(subscriberClass)` 方法，来看下 List<SubscriberMethod> 是怎么查找的

```java 
List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
    // 先查看 METHOD_CACHE 中是否已经存储过，是对 subscriberClass 和对应 List<SubscriberMethod> 一个缓存优化
    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
    if (subscriberMethods != null) {
        return subscriberMethods;
    }
    // ignoreGeneratedIndex 属性表示是否忽略注解器生成的 MyEventBusIndex，默认为false，可以通过 EventBusBuilder 来设置它的值
    if (ignoreGeneratedIndex) {
        //通过反射的形式获取
        subscriberMethods = findUsingReflection(subscriberClass);
    } else {
        subscriberMethods = findUsingInfo(subscriberClass);
    }
    if (subscriberMethods.isEmpty()) { 
        //如果注册的类中没有 SubscriberMethod 方法，直接抛出有异常
        throw new EventBusException("Subscriber " + subscriberClass
                + " and its super classes have no public methods with the @Subscribe annotation");
    } else { 
        //保存并返回 List<SubscriberMethod> 对象
        METHOD_CACHE.put(subscriberClass, subscriberMethods);
        return subscriberMethods;
    }
}
```

再来看下`SubscriberMethodFinder#findSubscriberMethods(subscriberClass)` 方法，该方法比较简单。

```java
private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
    FindState findState = prepareFindState(); //
    findState.initForSubscriber(subscriberClass);
    while (findState.clazz != null) {
        //核心方法，下面分析
        findUsingReflectionInSingleClass(findState);
        findState.moveToSuperclass(); //继续搜寻父类中的 @Subscriber 方法
    }
    return getMethodsAndRelease(findState); // 释放 FindState 对象到对象池
}
```
    
`SubscriberMethodFinder#prepareFindState()` 里面有个不错的知识点，采用对象池的方式缓存 FindState 对象。
    
```java
//对象池
private static final int POOL_SIZE = 4;
private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
//从对象池中获取 FindState 对象，没有的话就新建一个 FindState
private FindState prepareFindState() {
    synchronized (FIND_STATE_POOL) {
        for (int i = 0; i < POOL_SIZE; i++) {
            FindState state = FIND_STATE_POOL[i];
            if (state != null) {
                FIND_STATE_POOL[i] = null;
                return state;
            }
        }
    }
    return new FindState();
}
//使用完成之后将 FindState recycle , 并存储到 对象池中
private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
    List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
    findState.recycle();
    synchronized (FIND_STATE_POOL) {
        for (int i = 0; i < POOL_SIZE; i++) {
            if (FIND_STATE_POOL[i] == null) {
                FIND_STATE_POOL[i] = findState;
                break;
            }
        }
    }
    return subscriberMethods;
}
```
再来看下 `SubscriberMethodFinder#findUsingInfo(subscriberClass)` 方法，这方式是处理咱们上面讲过的 3.0+ 版本对 EventBus 的优化。
这个会先查询能不能根据注册的类获取到对用的 SubscriberInfo 对象，可以从 SubscriberInfo 中获取 SubscriberMethod list。
```java                                                                    
private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
    FindState findState = prepareFindState();
    findState.initForSubscriber(subscriberClass);
    while (findState.clazz != null) {
        findState.subscriberInfo = getSubscriberInfo(findState);
        if (findState.subscriberInfo != null) {
            // subscriberInfo 不为空，直接从 subscriberInfo 获取 SubscriberMethods
            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
            for (SubscriberMethod subscriberMethod : array) {
                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
                    findState.subscriberMethods.add(subscriberMethod);
                }
            }
        } else {
            findUsingReflectionInSingleClass(findState);
        }
        findState.moveToSuperclass();
    }
    return getMethodsAndRelease(findState);
}                                                                       
```                                                                        
再看下 `SubscriberMethodFinder#findUsingReflectionInSingleClass(findState)` 方法


