### 1. CoroutineScope.launch 方法

Builders.common.kt 中的 `CoroutineScope.launch` 方法

```kotlin
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job {
    //把当前context 加入到已有的CoroutineContext，并返回
    val newContext = newCoroutineContext(context)
    //创建一个协程，它们是继承了AbstractCoroutine
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    //执行协程，调用 AbstractCoroutine.kt 的 start 方法   
    coroutine.start(start, coroutine, block)
    return coroutine
}
```

AbstractCoroutine.kt 的 start 方法 

```kotlin
/**
 * Starts this coroutine with the given code [block] and [start] strategy.
 * This function shall be invoked at most once on this coroutine. 
 */
public fun <R> start(start: CoroutineStart, receiver: R, block: suspend R.() -> T) {
    //执行 CoroutineStart.kt 中的 invoke 方法
    start(block, receiver, this)
}
```

CoroutineStart.kt 中的 invoke 方法

```kotlin
@InternalCoroutinesApi
public operator fun <T> invoke(block: suspend () -> T, completion: Continuation<T>): Unit =
    when (this) {
        DEFAULT -> block.startCoroutineCancellable(completion)
        ATOMIC -> block.startCoroutine(completion)
        UNDISPATCHED -> block.startCoroutineUndispatched(completion)
        LAZY -> Unit // will start lazily
    }
```

### 参考：

[Kotlin协程源码分析-2 调用挂起函数](https://fanmingyi.blog.csdn.net/article/details/105027646)

[Kotlin Coroutine 源码解析（1） —— 协程是如何运行的](https://blog.csdn.net/xx326664162/article/details/113106875)

[Kotlin/kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines)
