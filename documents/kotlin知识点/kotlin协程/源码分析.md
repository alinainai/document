### 1. CoroutineScope.launch 启动一个协程

Builders.common.kt 中的 `CoroutineScope.launch` 方法

```kotlin
//Builders.common.kt
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job {
    //把当前context 加入到已有的CoroutineContext，并返回
    val newContext = newCoroutineContext(context)
    //创建一个协程，它们是继承了AbstractCoroutine
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    //执行协程，调用 AbstractCoroutine.kt 的 start 方法   
    coroutine.start(start, coroutine, block)
    return coroutine
}
```

lauch 方法最终调用 AbstractCoroutine.start 方法，start内部实际执行 CoroutineStart 的 invoke 方法。

```kotlin
//AbstractCoroutine.kt
/**
 * Starts this coroutine with the given code [block] and [start] strategy.
 * This function shall be invoked at most once on this coroutine. 
 */
public fun <R> start(start: CoroutineStart, receiver: R, block: suspend R.() -> T) {
    //执行 CoroutineStart.kt 中的 invoke 方法
    start(block, receiver, this)
}
```

CoroutineStart.kt 中的 invoke 方法，注意 invoke 方法是 '()' 操作符的重载

```kotlin
//CoroutineStart.kt
@InternalCoroutinesApi
public operator fun <T> invoke(block: suspend () -> T, completion: Continuation<T>): Unit =
    when (this) {
        DEFAULT -> block.startCoroutineCancellable(completion)
        ATOMIC -> block.startCoroutine(completion)
        UNDISPATCHED -> block.startCoroutineUndispatched(completion)
        LAZY -> Unit // will start lazily
    }
```

CoroutineStart.DEFAULT 模式下，最终调用 `协程代码块` block.startCoroutineCancellable(completion) 拓展函数

```kotlin
internal fun <R, T> (suspend (R) -> T).startCoroutineCancellable(
    receiver: R, completion: Continuation<T>,
    onCancellation: ((cause: Throwable) -> Unit)? = null
) = // runSafely 将 block() 包装到 try{}catch中运行
    runSafely(completion) {
        //分3步
        //1: (suspend R.() -> T).createCoroutineUnintercepted
        //2: intercepted()
        //3: resumeCancellableWith
        createCoroutineUnintercepted(receiver, completion).intercepted().resumeCancellableWith(Result.success(Unit), onCancellation)
    }
```
### 2. startCoroutineCancellable 的三步走

**第一步: intrinsicsJvm.kt 中的 createCoroutineUnintercepted 方法。注意代码中的 create 方法，生成一个 Continuation 对象。**

```kotlin
public actual fun <R, T> (suspend R.() -> T).createCoroutineUnintercepted(
    receiver: R,
    completion: Continuation<T>
): Continuation<Unit> {
    val probeCompletion = probeCoroutineCreated(completion)
    return if (this is BaseContinuationImpl)
        // 这个create方法是协程反编译后生成的，返回一个 Continuation
        create(receiver, probeCompletion)
    else {
        createCoroutineFromSuspendFunction(probeCompletion) {
            (this as Function2<R, Continuation<T>, Any?>).invoke(receiver, it)
        }
    }
}
```

create 如下，可以自己动手反编译一个 `协程` 代码查看，create 方法返回一个 Continuation 对象

```kotlin
public final Continuation create(@Nullable Object value, @NotNull Continuation completion) {
   Intrinsics.checkNotNullParameter(completion, "completion");
   Function2 var3 = new <anonymous constructor>(completion);
   return var3;
}
```
```kotlin
internal abstract class SuspendLambda(
    public override val arity: Int,
    completion: Continuation<Any?>?
) : ContinuationImpl(completion), FunctionBase<Any?>, SuspendFunction {
    //...
}
```

第一步的目的是将 block 生成 Continuation 对象

**第二步: intercepted 返回一个 DispatchedContinuation **

通过断点 intercepted 方法最终执行到 interceptContinuation 

```kotlin
public abstract class CoroutineDispatcher :
    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {
    //...
    public final override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> =
        DispatchedContinuation(this, continuation)
    //...
}
```

我们看下 DispatchedContinuation 的继承关系

```kotlin
internal class DispatchedContinuation<in T>(
    @JvmField val dispatcher: CoroutineDispatcher,
    @JvmField val continuation: Continuation<T>
) : DispatchedTask<T>(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation<T> by continuation {
    //...
}
```
DispatchedContinuation -> DispatchedTask -> SchedulerTask(Task) -> Runnable

第二步的 intercepted 将 Continuation 包装为一个 DispatchedContinuation 对象，用于第三步的分发执行

**第三步：resumeCancellableWith 方法执行协程 block**

```kotlin
internal class DispatchedContinuation<in T>(
    @JvmField val dispatcher: CoroutineDispatcher,
    @JvmField val continuation: Continuation<T>
) : DispatchedTask<T>(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation<T> by continuation {
    //...
    inline fun resumeCancellableWith(
        result: Result<T>,
        noinline onCancellation: ((cause: Throwable) -> Unit)?
    ) {
        val state = result.toState(onCancellation)
        if (dispatcher.isDispatchNeeded(context)) {
            _state = state
            resumeMode = MODE_CANCELLABLE
            dispatcher.dispatch(context, this) //CoroutineDispatcher 分发执行协程
        } else {
            executeUnconfined(state, MODE_CANCELLABLE) {
                if (!resumeCancelled(state)) {
                    resumeUndispatchedWith(result)
                }
            }
        }
    }
    //...
}
```

通过断点，dispatcher.dispatch 方法最终执行 EventLoopImplBase 中的 dispatch 方法

```kotlin
internal abstract class EventLoopImplBase: EventLoopImplPlatform(), Delay {
    //...
    public final override fun dispatch(context: CoroutineContext, block: Runnable) = enqueue(block)
    
    public fun enqueue(task: Runnable) {
        if (enqueueImpl(task)) {
            // todo: we should unpark only when this delayed task became first in the queue
            unpark()
        } else {
            DefaultExecutor.enqueue(task)
        }
    }
     //...
}
```

看下 EventLoopImplBase 的继承关系

EventLoopImplBase -> EventLoopImplPlatform -> EventLoop -> CoroutineDispatcher

### 3. 协程的执行



### 参考：

[Kotlin协程源码分析-2 调用挂起函数](https://fanmingyi.blog.csdn.net/article/details/105027646)

[Kotlin Coroutine 源码解析（1） —— 协程是如何运行的](https://blog.csdn.net/xx326664162/article/details/113106875)

[Kotlin/kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines)
