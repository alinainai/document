#### 定义
原型模式（Prototype Pattern）：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

#### 角色说明
- Prototype（抽象原型类）：抽象类或者接口，用来声明clone方法。
- ConcretePrototype1、ConcretePrototype2（具体原型类）：即要被复制的对象。
- Client（客户端类）：即要使用原型模式的地方。

#### 何时使用 
- 如果**初始化一个类时需要耗费较多的资源**，比如数据、硬件等等，可以使用原型拷贝来避免这些消耗。
- **通过new创建一个新对象时如果需要非常繁琐的数据准备或者访问权限**，那么也可以使用原型模式。
- 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以拷贝多个对象供调用者使用，即保护性拷贝，保证这个对象是只读的。
#### 优点
- 可以解决**复杂对象创建时消耗过多**的问题，在某些场景下提升创建对象的效率。
- **保护性拷贝**，可以防止外部调用者对对象的修改，保证这个对象是只读的。
- 逃避构造函数的约束，**拷贝对象时不会执行构造函数**。

#### 缺点 
配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 
#### 使用场景
- 1、资源优化场景。 
- 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 
- 3、性能和安全要求的场景。 
- 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 
- 5、一个对象多个修改者的场景。 
- 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 
- 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。

#### 代码实现
参考: Java 的深拷贝和浅拷贝 https://blog.csdn.net/u013728021/article/details/88874984

#### Android中的源码分析
Android中的Intent就实现了Cloneable接口，clone()方法中却是通过new Intent(Intent o)创建的，。
```java
 public class Intent implements Parcelable, Cloneable {
        //其他代码略
        @Override
        public Object clone() {
            return new Intent(this);//这里没有调用super.clone()来实现拷贝，而是直接通过new来创建
        }

        public Intent(Intent o) {
            this.mAction = o.mAction;
            this.mData = o.mData;
            this.mType = o.mType;
            this.mPackage = o.mPackage;
            this.mComponent = o.mComponent;
            this.mFlags = o.mFlags;
            this.mContentUserHint = o.mContentUserHint;
            if (o.mCategories != null) {
                this.mCategories = new ArraySet<String>(o.mCategories);
            }
            if (o.mExtras != null) {
                this.mExtras = new Bundle(o.mExtras);
            }
            if (o.mSourceBounds != null) {
                this.mSourceBounds = new Rect(o.mSourceBounds);
            }
            if (o.mSelector != null) {
                this.mSelector = new Intent(o.mSelector);
            }
            if (o.mClipData != null) {
                this.mClipData = new ClipData(o.mClipData);
            }
        }
    }
```
#### 总结 ：
实际上，调用clone()构造对象时并不一定比new快，使用clone()还是new来创建对象需要根据构造对象的成本来决定，如果对象的构造成本比较高或者构造比较麻烦，那么使用clone()的效率比较高，否则使用new。
#### 参考：
https://www.jianshu.com/p/6d1333917ae5
