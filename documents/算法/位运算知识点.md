
## 左移和右移规则

对左移而言，移动正数和负数规则是相同的；

对于右移而言，则有些差别，正数补0，负数补1。 
举例说明： 
- 对于一个16位的整数：0000 0000 0000 0101，左移一位是0000 0000 0000 1010，右移一位是0000 0000 0000 0010 
- 对于一个16位的负数：1000 0000 0000 0101，左移一位是0000 0000 0000 1010，右移一位是1100 0000 0000 0010

### and 运算 

and 运算通常用于二进制取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数.

### or 运算

or 运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。

### xor运算

xor 运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：0和1异或0都不变，异或1则取反。

xor 运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即(a xor b) xor b = a。

xor 运算可以用于简单的加密，双方约定 19880516 作为密钥，如果明文是 1314520 ，加密一下 1314520 xor 19880516 = 20665500，我就把密文 20665500 发送。得到密文之后 可以通过 20665500 xor 19880516 解密得到1314520

下面通过几个典型的题目来透彻分析位运算的一些常用技巧。

#### 技巧一：`a>>1`

对于`正整数`，左移一位，就是将数值乘2；右移一位就运算数值除2；但是位操作的效率要比运算符高。

#### 技巧二：`a^b^b=a`

一个数和另一个数异或两次得到的还是原来的数，如：不用临时变量交换两个整数。
```java
a = a ^ b;
b = a ^ b;
a = a ^ b;
```
## 技巧三：`n & (n - 1)`

`n & (n - 1)` 将整数 n 二进制中的最后一位为 1 的位变成 0

**题1：统计一个整数中二进制位上1的个数。**

```c++
int fun(int num)
{
    int count = 0;
    while(num)
    {
        num = num & (num - 1);
        ++count;
    }
    return count；
}
```

**题2：判断一个数是不是2的幂。**
```c++
//返回0表示是2的幂，返回非0值表示不是2的幂
int fun(int n)
{
    return n & (n - 1);
}
```
解析：如果一个数是 2 的幂，则其有且只有一位为 1。因此，消除这一位后就会变成0

**题3：判断一个32位整数是不是4的幂**
```java
//返回0表示不是4的幂，返回非0表示是4的幂
int fun(int n)
{
    if(!(n & (n - 1)))
    {
        return (n & 0x55555555);
    }
    return 0;
}
```

解析：是 4 的幂的数一定是 2 的幂，因此先判断是不是 2 的幂，2 的幂中 1 在奇数位上的是 4 的幂，与 0x55555555 按位与，如果在奇数位上有数则不为0

**题4：输入两个整数m和n，计算需要改变多少位能使m变成n**
```java
int fun(int m, int n)
{
    m = m ^ n; // 将m和n按位异或，相同的位为0，不同的位为1
    int count = 0;
    while(m) //统计不同的位有多少个就ok
    {
        m = m & (m - 1);
        ++count;
    }
    return count；
}
```

## 技巧四：`n & (~n + 1)`
`n & (~n + 1)`提取出 整数n 最后一位为 1 的数 
举例：`n = 01101`，`~n`是将`n`按位取反就是`10010`，`~n + 1 = 10011`，最后，`n & (~n + 1)` = 00001

题：统计一个整数中二进制位上1的个数。
```java
int fun(int n)
{
    int count = 0;
    while(n)
    {
        n -= n & (~n + 1);
        ++count;
    }
    return count；
}
```


## 技巧五：不使用+，-，*，/完成整数相加

```java
 int Add(int num1, int num2)
 {
     int sum, carry;
     do{
         //将两个数异或，模拟加法中相加不进位的结果
         sum = num1 ^ num2;
         //只考虑进位的情况
         carry = (num1 & num2) << 1;
         num1 = sum;
         num2 = carry;
     }
     while(num2 != 0); //将结果相加的过程就重复上述过程，直到进位为0

     return sum;
 }
```
## 技巧六：

对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）

计算n+1
```java
-~n
```
计算n-1
```java
~-n
```

取相反数
```java
~n + 1;
```
另一种写法
```java
(n ^ -1) + 1;
```
```java
if(x == a) 
	x = b; 
if(x == b) 
	x = a;
```
等价于
```java
x = a ^ b ^ x;
```
## 技巧七：n & 1
判断奇偶性
```java
/* 判断是否是奇数 */
bool is_odd(int n)
{
    return (n & 1 == 1);
}
