### 1.运行时数据区

<img width="400" alt="类图" src="https://user-images.githubusercontent.com/17560388/132071778-9edaabe1-0fc8-4fd8-a476-b361a90ed53b.png">

1. 虚拟机栈: 线程私有，虚拟机栈和线程的生命周期相同，线程运行方法时会在虚拟机栈中为方法创建一个`栈帧`。

2. 本地方法栈: 线程私有的，native 方法使用。

3. 程序计数器: 线程私有的，Java 程序是多线程的，CPU 可以在多个线程中分配执行时间片段。当某一个线程被 CPU 挂起时，需要记录代码已经执行到的位置，方便 CPU 重新执行此线程时，知道从哪行指令开始执行。这就是程序计数器的作用。

4. 堆: 线程共享的，用来存放大部分实例对象。GC 。

5. 方法区: 线程共享，存储类元信息、常量、静态变量。

### 2. 栈帧

栈帧结构如下图：

<img width="400" alt="栈帧结构" src="https://user-images.githubusercontent.com/17560388/150509470-d9b93dc6-cbe6-43c7-9c19-508f466ff1f4.png">

1. 局部变量表: 存储调用方法时传递的参数、方法内部创建的局部变量。在 java 编译成 class 的时候就已经确定好容量（Code 属性表中的 max_locals 数据项）。
2. 操作数栈: Code属性表中的max_stacks
3. 动态链接
4. 返回地址: 正常返回和异常返回

### 3. GC 回收机制

- **什么是垃圾**: 不再使用的对象。
- **可达性分析**: GCRoot 作为起点。

#### 3.1 什么可以作为GCRoot：

1. Java 虚拟机栈（局部变量表）中的引用的对象。

2. 方法区中静态引用指向的对象。

3. 仍处于存活状态中的线程对象。

4. Native 方法中 JNI 引用的对象。

#### 3.2 回收时机

1. Allocation Failure（可用剩余空间不足导致对象内存分配失败）
2. System.gc()

### 4. 回收算法

#### 4.1 标记清除算法（Mark and Sweep GC）

<img width="500" alt="类图" src="https://user-images.githubusercontent.com/17560388/133190305-c79ae35c-cc5b-42a7-842b-f4e547ef69d8.png">

- 优点：实现简单，不需要将对象进行移动。
- 缺点：这个算法需要中断进程内其他组件的执行（stop the world），并且可能产生内存碎片，提高了垃圾回收的频率。

#### 4.2 复制算法（Copying）

<img width="500" alt="类图" src="https://user-images.githubusercontent.com/17560388/133190386-0ba6de67-a3d5-4d8d-a7b9-99af3312d6c1.png">

- 优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。
- 缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。

#### 4.3 标记-整理算法 (Mark-Compact)

<img width="500" alt="类图" src="https://user-images.githubusercontent.com/17560388/133190437-f33e6005-789b-422a-9e61-92481570d431.png">

- 优点：这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。
- 缺点：所谓压缩操作，仍需要进行局部对象移动，所以一定程度上还是降低了效率。

### 5. 分代回收策略

新生代的回收策略 

1. Eden:S0:S1 = 8:1:1

2. Eden + S0 -> S1;

3. Eden + S1 -> S0;

4. 老年代: 新生代年龄 `>15` 没被回收放到老年代。

初始化大对象 `-XX:PretenureSizeThreshold` 直接分配到老年代。

- 新生代 GC：这一区域的 GC 叫作 Minor GC。因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。
- 老年代 GC：发生在这一区域的 GC 也叫作 Major GC 或者 Full GC。当出现了 Major GC，经常会伴随至少一次的 Minor GC。

###  注意
对于老年代可能存在这么一种情况，老年代中的对象有时候会引用到新生代对象。这时如果要执行新生代 GC，则可能需要查询整个老年代上可能存在引用新生代的情况，这显然是低效的。
所以，老年代中维护了一个 512 byte 的 card table，所有老年代对象引用新生代对象的信息都记录在这里。每当新生代发生 GC 时，只需要检查这个 card table 即可，大大提高了性能。

