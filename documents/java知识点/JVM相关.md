
### 1.运行时数据区

<img width="400" alt="类图" src="https://user-images.githubusercontent.com/17560388/132071778-9edaabe1-0fc8-4fd8-a476-b361a90ed53b.png">

1. 虚拟机栈: 线程私有，虚拟机栈和线程的生命周期相同，线程运行方法时会在虚拟机栈中为方法创建一个`栈帧`。

2. 本地方法栈: 线程私有的，native 方法使用。

3. 程序计数器: 线程私有的，Java 程序是多线程的，CPU 可以在多个线程中分配执行时间片段。当某一个线程被 CPU 挂起时，需要记录代码已经执行到的位置，方便 CPU 重新执行此线程时，知道从哪行指令开始执行。这就是程序计数器的作用。

4. 堆: 线程共享的，用来存放大部分实例对象。GC 。

5. 方法区: 线程共享，存储类元信息、常量、静态变量。

栈帧结构如下图：

<img width="150" alt="栈帧结构" src="https://user-images.githubusercontent.com/17560388/132072640-1967c247-aede-4d06-849e-c16aad7e6efa.png">


### 2. GC 回收机制 与 分代回收策略

- **什么是垃圾**: 不再使用的对象。
- **可达性分析**:GCRoot 作为起点。

#### 2.1 什么可以作为GCRoot：

1. Java 虚拟机栈（局部变量表）中的引用的对象。

2. 方法区中静态引用指向的对象。

3. 仍处于存活状态中的线程对象。

4. Native 方法中 JNI 引用的对象。

#### 2.2 回收时机

1. Allocation Failure

2. System.gc()

#### 2.3 标记清除算法（Mark and Sweep GC）

<img width="500" alt="类图" src="https://user-images.githubusercontent.com/17560388/133190305-c79ae35c-cc5b-42a7-842b-f4e547ef69d8.png">

- 优点：实现简单，不需要将对象进行移动。
- 缺点：这个算法需要中断进程内其他组件的执行（stop the world），并且可能产生内存碎片，提高了垃圾回收的频率。

#### 2.4 复制算法（Copying）

<img width="500" alt="类图" src="https://user-images.githubusercontent.com/17560388/133190386-0ba6de67-a3d5-4d8d-a7b9-99af3312d6c1.png">

- 优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。
- 缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。

#### 2.5 标记-压缩算法 (Mark-Compact)

<img width="500" alt="类图" src="https://user-images.githubusercontent.com/17560388/133190437-f33e6005-789b-422a-9e61-92481570d431.png">

- 优点：这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。
- 缺点：所谓压缩操作，仍需要进行局部对象移动，所以一定程度上还是降低了效率。

#### 2.6 分代回收策略

新生代的回收策略 

1. Eden:S0:S1 = 8:1:1

2. Eden + S0 -> S1;

3. Eden + S1 -> S0;

4. 老年代: 新生代年龄 `>15` 没被回收放到老年代。

初始化大对象 `-XX:PretenureSizeThreshold` 直接分配到老年代。

### 3. 注意
对于老年代可能存在这么一种情况，老年代中的对象有时候会引用到新生代对象。这时如果要执行新生代 GC，则可能需要查询整个老年代上可能存在引用新生代的情况，这显然是低效的。
所以，老年代中维护了一个 512 byte 的 card table，所有老年代对象引用新生代对象的信息都记录在这里。每当新生代发生 GC 时，只需要检查这个 card table 即可，大大提高了性能。







